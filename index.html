<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-K13VH578CQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K13VH578CQ');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet" />

  <style>
    :root {
      --font-sans: 'DM Sans', system-ui, sans-serif;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --bg-dark: #0f1419;
      --surface-1: rgba(20, 30, 40, 0.75);
      --surface-2: rgba(15, 23, 32, 0.9);
      --border-color: rgba(255, 255, 255, 0.1);
      --accent: #7db8a8;
      --accent-dark: #1a2a2e;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-sans);
      background-color: var(--bg-dark);
      color: var(--text-primary);
      overflow: hidden;
      cursor: default;
    }

    /* Menu */
    #menu {
      position: fixed;
      top: 20px;
      left: 20px;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 20px 26px;
      width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      transition: all 0.3s ease;
      transform-origin: top left;
    }

    #menu.closed {
      width: auto;
      padding: 16px 14px;
      flex-direction: row;
      align-items: center;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box,
    #menu.closed #community-section,
    #menu.closed #mobile-search-section {
      display: none;
    }

    #title {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 0;
      color: var(--text-primary);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: var(--accent);
    }

    #subtitle {
      font-size: 0.95rem;
      line-height: 1.6;
      opacity: 0.85;
      color: var(--text-secondary);
      margin: 0;
    }

    #nav-box {
      background: rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 16px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    nav ul li a {
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      font-size: 1.05rem;
      padding: 10px 16px;
      border-radius: 6px;
      display: block;
      transition: all 0.2s ease;
    }

    nav ul li a:hover {
      background: var(--accent);
      color: var(--accent-dark);
      transform: translateX(2px);
    }
    
    /* Community & Mobile Search */
    #community-section, #mobile-search-section {
      background: rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 16px;
    }

    #community-title, #search-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: var(--text-primary);
    }

    #community-select {
      width: 100%;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 12px 16px;
      font-size: 0.95rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #community-select:hover {
      border-color: rgba(255, 255, 255, 0.2);
    }

    #community-select:focus, .search-input:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #community-select option {
      background: var(--surface-2);
      color: var(--text-primary);
    }

    /* Search Section */
    .desktop-search {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
        width: 300px;
    }

    .search-box {
        position: relative;
        display: flex;
        align-items: center;
        gap: 4px;
        transition: border-color 0.3s ease;
        border: 1px solid transparent;
        border-radius: 12px;
        background: var(--surface-1);
        backdrop-filter: blur(12px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
        padding: 4px;
    }
    .search-box:focus-within {
        border-color: var(--accent);
    }


    .search-input {
      flex-grow: 1;
      background: transparent;
      border: none;
      color: var(--text-primary);
      padding: 10px 14px;
      font-size: 0.95rem;
      font-weight: 500;
      font-family: inherit;
      outline: none;
    }
    .search-input::placeholder {
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .search-btn, .random-btn {
      padding: 0;
      width: 36px;
      height: 36px;
      flex-shrink: 0;
      font-size: 1.2rem;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      border-radius: 8px;
    }
    .search-btn:hover, .random-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
    }

    #mobile-search-section {
        display: none;
    }
    #mobile-search-section .search-box {
        background: rgba(0,0,0,0.2);
        border: 1px solid var(--border-color);
        padding: 4px;
    }


    .autocomplete-results {
        display: none;
        position: absolute;
        top: 105%;
        left: 0;
        right: 0;
        background: var(--surface-2);
        backdrop-filter: blur(12px);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        max-height: 220px;
        overflow-y: auto;
        z-index: 999;
        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }

    .autocomplete-item {
        padding: 12px 16px;
        cursor: pointer;
        color: var(--text-primary);
        transition: all 0.2s ease;
        font-size: 0.9rem;
        border-bottom: 1px solid var(--border-color);
    }
    .autocomplete-item:last-child {
        border-bottom: none;
    }

    .autocomplete-item small {
        opacity: 0.7;
        display: block;
        font-size: 0.8rem;
    }

    .autocomplete-item:hover, .autocomplete-item.active {
        background: var(--accent);
        color: var(--accent-dark);
    }


    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-primary);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 180px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* Buttons */
    button {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 12px 20px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      background: var(--accent);
      color: var(--accent-dark);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      border-color: var(--accent);
    }

    button:active {
      transform: translateY(0);
    }

    #toggle-btn {
      width: 44px;
      height: 44px;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 44px;
      height: 180px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 0.9rem;
      border-radius: 10px;
    }

    /* Copy confirmation */
    #copy-confirmation {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translate(-50%, 40px);
      background: var(--accent);
      color: var(--accent-dark);
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    /* 3D graph container */
    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: transparent;
    }

    #graph-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(15, 20, 25, 0.6) 100%);
      z-index: 1;
      pointer-events: none;
    }
    
    /* Legend */
    #legend {
      position: fixed;
      top: 90px;
      right: 20px;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 99;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      transition: all 0.3s ease;
      max-width: 220px;
      display: none;
    }

    #legend.visible {
      display: block;
    }

    #legend-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: var(--text-primary);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255, 0.2);
      flex-shrink: 0;
    }

    .legend-label {
      color: var(--text-secondary);
      font-weight: 500;
      transition: color 0.2s ease;
    }
    .legend-item:hover .legend-label {
        color: var(--text-primary);
    }

    /* Breathing toggle button */
    #breathing-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      color: var(--accent);
    }

    #breathing-toggle:hover {
      transform: scale(1.05);
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.2);
    }

    #breathing-toggle.active {
      background: var(--accent);
      color: var(--accent-dark);
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.4);
    }

    /* Responsive improvements */
    @media (max-width: 768px) {
      #menu {
        width: calc(100vw - 32px);
        padding: 16px 20px;
        top: 16px;
        left: 16px;
      }

      #menu.closed {
        padding: 12px 10px;
        width: auto;
      }

      .desktop-search {
        display: none;
      }
      #mobile-search-section {
        display: block;
      }
      #legend {
        display: none !important;
      }


      #breathing-toggle {
        bottom: 16px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 1.3rem;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* Focus states for keyboard navigation */
    button:focus,
    nav ul li a:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <div id="community-section">
        <h3 id="community-title">Community View</h3>
        <select id="community-select">
          <option value="none">Default View</option>
          <option value="author">By Author</option>
          <option value="phase">By Project Phase</option>
        </select>
    </div>
    <div id="mobile-search-section">
      <h3 id="search-title">Find Artwork</h3>
      <div class="search-box">
        <input type="text" class="search-input" placeholder="Search piece or artist...">
        <button class="search-btn" aria-label="Search">🔍</button>
        <button class="random-btn" aria-label="Jump to random node">🎲</button>
        <div class="autocomplete-results"></div>
      </div>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn" aria-label="Toggle menu">×</button>
      <button id="copy-btn">📋 Copy network<br>adjacency matrix</button>
    </div>
  </nav>

  <div class="desktop-search">
    <div class="search-box">
      <input type="text" class="search-input" placeholder="Search piece or artist...">
      <button class="search-btn" aria-label="Search">🔍</button>
      <button class="random-btn" aria-label="Jump to random node">🎲</button>
      <div class="autocomplete-results"></div>
    </div>
  </div>

  <div id="copy-confirmation" role="alert" aria-live="polite">Copied!</div>
  <div id="legend">
    <h4 id="legend-title">Communities</h4>
    <div id="legend-items"></div>
  </div>
  <div id="breathing-toggle" title="Toggle organism breathing" aria-label="Toggle breathing animation">
    💨
  </div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // State
    let Graph;
    let nodes = [];
    let links = [];
    let adjacencyMatrix = [];
    let communities = {};
    let colors = {};
    let uniqueArtists = [];
    let currentCommunityView = 'none';
    let isBreathing = false; // Off by default
    let isEngineSettled = false;
    let breathingInterval = null;
    let hoverNode = null;
    let activeLegendCategory = null;
    let autocompleteIndex = -1;
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    const nodeSprites = new Map();
    const proximityThreshold = 100; // Distance to trigger high-res load
    const thumbnailTextures = new Map();
    const highresTextures = new Map();
    
    const artistNameMap = {
        "Arango Franco Sara": "Sara Arango-Franco",
        "Bulla Lina": "Lina Bulla",
        "Camacho Cabrera Gabriel": "Gabriel Camacho Cabrera",
        "elly": "Ellynne dec",
        "Emerson Paquette": "Emerson Paquette",
        "Louison Halgand": "Louison Halgand",
        "Nadine AbdElRazek": "Nadine AbdElRazek",
        "Phileas Dazeley Gaist": "Phileas Dazeley-Gaist",
        "Sonal Raghuvanshi": "Sonal Raghuvanshi",
        "Thompson Kyle": "Kyle Thompson"
    };

    // Helper to generate a color palette
    function generateColorPalette(keys) {
        const palette = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#FFA07A", "#98D8C8", "#F7DC6F", "#BB8FCE", "#F1948A"];
        const colorMap = {};
        keys.forEach((key, index) => {
            colorMap[key] = palette[index % palette.length];
        });
        return colorMap;
    }

    // Fetches and processes graph data from JSON files
    async function loadAndProcessGraphData() {
        try {
            const [verticesRes, edgesRes] = await Promise.all([
                fetch('./graph/vertices.json'),
                fetch('./graph/edges.json')
            ]);

            if (!verticesRes.ok || !edgesRes.ok) {
                throw new Error(`Failed to load graph data files. Status: Vertices ${verticesRes.status}, Edges ${edgesRes.status}`);
            }

            const verticesMap = await verticesRes.json();
            const edgesList = await edgesRes.json();
            
            const tempCommunities = { author: {}, phase: {} };
            const uniqueAuthorsSet = new Set();
            const uniquePhases = new Set();

            // Build graph data
            const localNodes = Object.entries(verticesMap).map(([id, filename]) => {
                const parts = filename.split('-');
                const phase = `Phase ${parts[0]}`;
                const authorFromFile = (parts[1] || 'Unknown').replace(/_/g, ' ');
                const author = artistNameMap[authorFromFile] || authorFromFile;

                uniqueAuthorsSet.add(author);
                uniquePhases.add(phase);

                if (!tempCommunities.author[author]) tempCommunities.author[author] = [];
                tempCommunities.author[author].push(parseInt(id, 10));

                if (!tempCommunities.phase[phase]) tempCommunities.phase[phase] = [];
                tempCommunities.phase[phase].push(parseInt(id, 10));

                return {
                    id: parseInt(id, 10),
                    img: `${filename}.jpeg`,
                    name: filename.replace(/_/g, ' '),
                    author,
                    phase,
                    neighbors: [],
                    links: [],
                    textureState: 'thumbnail'
                };
            });
            
            uniqueArtists = Array.from(uniqueAuthorsSet).sort();
            const sortedPhases = Array.from(uniquePhases).sort();

            const tempColors = {
                author: generateColorPalette(uniqueArtists),
                phase: generateColorPalette(sortedPhases)
            };


            const localLinks = edgesList.map(([source, target]) => ({
                source: parseInt(source, 10),
                target: parseInt(target, 10)
            }));
            
            const edgeSet = new Set(edgesList.map(([s, t]) => `${s},${t}`));

            localLinks.forEach(link => {
                const revLinkExists = edgeSet.has(`${link.target},${link.source}`);
                if (revLinkExists) {
                    link.curvature = link.source < link.target ? 0.4 : -0.4;
                    link.rotation = link.source < link.target ? 0 : Math.PI / 2;
                } else {
                    link.curvature = 0;
                    link.rotation = 0;
                }
            });

            const nodeMap = new Map(localNodes.map(node => [node.id, node]));
            localLinks.forEach(link => {
                const a = nodeMap.get(link.source);
                const b = nodeMap.get(link.target);
                if (a && b) {
                    a.neighbors.push(b);
                    b.neighbors.push(a);
                    a.links.push(link);
                    b.links.push(link);
                }
            });

            const nodeIds = localNodes.map(n => n.id);
            const maxId = Math.max(0, ...nodeIds);
            const localAdjacencyMatrix = Array(maxId + 1).fill(0).map(() => Array(maxId + 1).fill(0));
            edgesList.forEach(([source, target]) => {
                if (source <= maxId && target <= maxId) {
                    localAdjacencyMatrix[source][target] = 1;
                }
            });
            
            return { 
                nodes: localNodes, 
                links: localLinks, 
                adjacencyMatrix: localAdjacencyMatrix,
                communities: tempCommunities,
                colors: tempColors
            };
        } catch (error) {
            console.error("Error loading graph:", error);
            document.getElementById('3d-graph').innerHTML = `<div style="color: #ff6b6b; padding: 40px; text-align: center; font-size: 1.2rem;"><h2>Failed to Load Organism</h2><p>${error.message}</p><p>Please check the console for more details.</p></div>`;
            return null;
        }
    }

    // Helper functions
    function getNodeColor(node) {
      if (highlightNodes.has(node)) {
        return node === hoverNode ? '#A8E6A3' : '#C8F4C3';
      }
      
      if (currentCommunityView === 'none') return '#ffffff';
      
      const communityData = communities[currentCommunityView];
      const colorData = colors[currentCommunityView];
      
      if (communityData && colorData) {
        const key = node[currentCommunityView];
        if (key && colorData[key]) {
            return colorData[key];
        }
      }
      
      return '#ffffff';
    }

    function getLinkColor(link) {
        if (highlightLinks.has(link)) return '#7ED377';
        if (currentCommunityView === 'none' || !link.source.id || !link.target.id) return '#7db8a8';

        const communityData = communities[currentCommunityView];
        const colorData = colors[currentCommunityView];
        
        const sourceNode = nodes.find(n => n.id === link.source.id);
        const targetNode = nodes.find(n => n.id === link.target.id);
        
        if (sourceNode && targetNode && communityData && colorData) {
            const sourceCommunity = sourceNode[currentCommunityView];
            const targetCommunity = targetNode[currentCommunityView];
            
            if (sourceCommunity && targetCommunity) {
                return sourceCommunity === targetCommunity ? colorData[sourceCommunity] : '#FFA726'; // Orange for inter-community links
            }
        }
      
      return '#7db8a8';
    }

    function updateHighlight() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph
        .linkWidth(link => highlightLinks.has(link) ? 3 : 1.5)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0)
        .linkDirectionalArrowLength(link => highlightLinks.has(link) ? 12 : 8)
        .linkDirectionalArrowColor(link => highlightLinks.has(link) ? '#7ED377' : getLinkColor(link))
        .linkColor(getLinkColor);
    }

    // Breathing system
    function startBreathing() {
      if (breathingInterval || !isEngineSettled) return;
      
      let phase = 0;
      
      breathingInterval = setInterval(() => {
        phase += 0.02; // Adjust speed of the breathing cycle

        nodes.forEach(node => {
            if (!node.__threeObj) return;
            
            // Apply a noticeable scaling effect, timed with the breathing
            const scalePhase = phase + (node.id * 0.5); // Offset phase per node
            const scale = 25 * (1 + 0.4 * Math.sin(scalePhase)); // More pronounced scale variation
            node.__threeObj.scale.setScalar(scale);
        });

        // Fluctuate link width and opacity to create a "pulsing" or "breathing" effect through the connections.
        const pulseFactor = 1 + 0.9 * Math.sin(phase * 1.5); // More pronounced variation (0.1 to 1.9)
        Graph.linkWidth(link => (highlightLinks.has(link) ? 3 : 1.5) * pulseFactor);

        // Fluctuate link opacity with a slight phase shift from the width pulse for a more dynamic feel
        const linkOpacity = 0.65 + 0.2 * Math.sin(phase * 1.5 + Math.PI / 2);
        Graph.linkOpacity(Math.max(0.35, Math.min(0.85, linkOpacity)));

      }, 40);
    }

    function stopBreathing() {
      if (breathingInterval) {
        clearInterval(breathingInterval);
        breathingInterval = null;
      }
      
      // Reset nodes scale
      nodes.forEach(node => {
          if (node.__threeObj) {
              node.__threeObj.scale.setScalar(22);
          }
      });
      
      Graph.linkOpacity(0.8);
      updateHighlight(); // Resets link widths and other properties based on the current hover state.
    }
    
    // Dynamic Texture Loading System
    function manageDynamicTextures() {
        if (!Graph || !Graph.camera()) return;

        const cameraPosition = Graph.camera().position;

        nodes.forEach(node => {
            if (!node.__threeObj) return;

            const nodePosition = node.__threeObj.position;
            const distance = cameraPosition.distanceTo(nodePosition);

            if (distance < proximityThreshold) {
                if (node.textureState === 'thumbnail') {
                    node.textureState = 'loading_highres';

                    const highResUrl = `./art-imgs/${node.img}`;
                    new THREE.TextureLoader().load(
                        highResUrl,
                        (highResTexture) => {
                            highResTexture.colorSpace = THREE.SRGBColorSpace;
                            if (node.__threeObj) {
                                node.__threeObj.material.map = highResTexture;
                                highresTextures.set(node.id, highResTexture);
                                node.textureState = 'highres';
                            } else {
                               highResTexture.dispose();
                            }
                        },
                        undefined,
                        (error) => {
                            console.error(`Failed to load high-res image for node ${node.id}: ${highResUrl}`, error);
                            node.textureState = 'thumbnail';
                        }
                    );
                }
            } else {
                if (node.textureState === 'highres') {
                    const thumbnailTexture = thumbnailTextures.get(node.id);
                    if (thumbnailTexture && node.__threeObj) {
                        node.__threeObj.material.map = thumbnailTexture;
                    }

                    const highResTexture = highresTextures.get(node.id);
                    if (highResTexture) {
                        highResTexture.dispose();
                        highresTextures.delete(node.id);
                    }
                    node.textureState = 'thumbnail';
                }
            }
        });
    }

    function startTextureManagementLoop() {
        function animate() {
            manageDynamicTextures();
            requestAnimationFrame(animate);
        }
        animate();
    }


    // Initialize graph
    function initGraph() {
      Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .graphData({ nodes, links })
        .backgroundColor('rgba(0,0,0,0)')
        .nodeThreeObject(node => {
            const currentNode = { ...node };
            const material = new THREE.SpriteMaterial({
                transparent: true,
                opacity: 0.9,
                color: getNodeColor(currentNode)
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(22, 22, 1);
            nodeSprites.set(currentNode.id, sprite);

            const loader = new THREE.TextureLoader();
            loader.load(
                `./art-thumbnails/${currentNode.img}`,
                (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    thumbnailTextures.set(currentNode.id, texture);
                    const spriteToUpdate = nodeSprites.get(currentNode.id);
                    if (spriteToUpdate) {
                        spriteToUpdate.material.map = texture;
                        spriteToUpdate.material.color.set(getNodeColor(currentNode));
                        spriteToUpdate.material.needsUpdate = true;
                    }
                },
                undefined,
                (error) => {
                    console.error(`Image failed for node ${currentNode.id} (${currentNode.img}):`, error);
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#2a3b4d';
                    ctx.fillRect(0, 0, 128, 128);
                    ctx.fillStyle = '#c2d4d0';
                    ctx.font = '16px "DM Sans", system-ui, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Image', 64, 56);
                    ctx.fillText('Not Found', 64, 72);
                    
                    const fallbackTexture = new THREE.CanvasTexture(canvas);
                    thumbnailTextures.set(currentNode.id, fallbackTexture);

                    const spriteToUpdate = nodeSprites.get(currentNode.id);
                    if (spriteToUpdate) {
                        spriteToUpdate.material.map = fallbackTexture;
                        spriteToUpdate.material.needsUpdate = true;
                    }
                }
            );
            
            return sprite;
        })
        .nodeColor(() => null)
        .linkWidth(1.5)
        .linkDirectionalArrowLength(8)
        .linkDirectionalArrowRelPos(0.85)
        .linkColor(getLinkColor)
        .linkOpacity(0.8)
        .linkCurvature(link => link.curvature || 0)
        .linkCurveRotation(link => link.rotation || 0)
        .nodeLabel(node => {
          const fileName = node.img.split('/').pop().split('.')[0];
          let communityInfo = '';
          if (currentCommunityView !== 'none') {
              communityInfo = `<br><small>${node[currentCommunityView]}</small>`;
          }
          return `<div style="background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; color: var(--text-primary); font-size: 12px; font-weight: 500;">${fileName}${communityInfo}</div>`;
        })
        .onNodeHover(node => {
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          activeLegendCategory = null;
          updateLegendStyles();

          highlightNodes.clear();
          highlightLinks.clear();

          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(n => highlightNodes.add(n));
            node.links.forEach(l => highlightLinks.add(l));
          }

          hoverNode = node || null;
          updateHighlight();
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          activeLegendCategory = null;
          updateLegendStyles();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }

          updateHighlight();
        })
        .onNodeClick(node => {
          if (!node) return;
          const distance = 60;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
          const newPos = {
            x: node.x * distRatio,
            y: node.y * distRatio,
            z: node.z * distRatio
          };
          Graph.cameraPosition(newPos, node, 2000);
        })
        .onEngineStop(() => {
            console.log("Force engine stopped. Capturing natural positions.");
            nodes.forEach(node => {
                node.naturalX = node.x;
                node.naturalY = node.y;
                node.naturalZ = node.z;
            });
            isEngineSettled = true;

            if (isBreathing) {
                startBreathing();
            }
        });

      Graph.controls().enableDamping = true;
      Graph.controls().dampingFactor = 0.05;
    }
    
    // UI Event handlers
    function updateLegendStyles() {
        const legendItems = document.querySelectorAll('.legend-item');
        legendItems.forEach(item => {
            const itemName = item.dataset.name;
            if (activeLegendCategory === null || activeLegendCategory === itemName) {
                item.style.opacity = '1';
                item.style.transform = 'translateX(0)';
            } else {
                item.style.opacity = '0.5';
                item.style.transform = 'translateX(-2px)';
            }
        });
    }

    function updateCommunityView() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph.linkColor(getLinkColor);
      
      // Update legend
      const legend = document.getElementById('legend');
      const legendItems = document.getElementById('legend-items');
      
      if (currentCommunityView === 'none') {
        legend.classList.remove('visible');
        return;
      }
      
      legend.classList.add('visible');
      legendItems.innerHTML = '';
      
      const colorData = colors[currentCommunityView];
      
      if (colorData) {
        Object.entries(colorData).sort((a, b) => a[0].localeCompare(b[0])).forEach(([name, color]) => {
          const item = document.createElement('div');
          item.className = 'legend-item';
          item.dataset.name = name;
          item.style.cursor = 'pointer';
          
          const colorBox = document.createElement('div');
          colorBox.className = 'legend-color';
          colorBox.style.backgroundColor = color;
          
          const label = document.createElement('span');
          label.className = 'legend-label';
          label.textContent = name;
          
          item.appendChild(colorBox);
          item.appendChild(label);
          legendItems.appendChild(item);

          item.addEventListener('click', () => {
              if (activeLegendCategory === name) {
                  activeLegendCategory = null;
                  highlightNodes.clear();
                  highlightLinks.clear();
              } else {
                  activeLegendCategory = name;
                  highlightNodes.clear();
                  highlightLinks.clear();

                  const nodeIdsToHighlight = communities[currentCommunityView][name];
                  if (nodeIdsToHighlight) {
                      const nodesInCommunity = new Set();
                      nodeIdsToHighlight.forEach(id => {
                          const nodeToHighlight = nodes.find(n => n.id === id);
                          if (nodeToHighlight) {
                              highlightNodes.add(nodeToHighlight);
                              nodesInCommunity.add(nodeToHighlight);
                          }
                      });

                      links.forEach(link => {
                          if (nodesInCommunity.has(link.source) && nodesInCommunity.has(link.target)) {
                              highlightLinks.add(link);
                          }
                      });
                  }
              }
              updateHighlight();
              updateLegendStyles();
          });
        });
      }
    }

    function closeAllAutocompletes() {
        document.querySelectorAll('.autocomplete-results').forEach(el => el.style.display = 'none');
    }

    // Event listeners
    document.getElementById('toggle-btn').addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const isOpen = !menu.classList.contains('closed');
      menu.classList.toggle('closed', isOpen);
      document.getElementById('toggle-btn').textContent = isOpen ? '☰' : '×';
    });

    document.getElementById('community-select').addEventListener('change', (e) => {
        currentCommunityView = e.target.value;
        activeLegendCategory = null;
        updateCommunityView();
    });

    document.getElementById('breathing-toggle').addEventListener('click', () => {
      const toggle = document.getElementById('breathing-toggle');
      isBreathing = !isBreathing;
      if (isBreathing) {
        startBreathing();
        toggle.classList.add('active');
      } else {
        stopBreathing();
        toggle.classList.remove('active');
      }
    });

    document.getElementById('copy-btn').addEventListener('click', async () => {
      const text = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
      }
      const confirm = document.getElementById('copy-confirmation');
      confirm.classList.add('visible');
      setTimeout(() => confirm.classList.remove('visible'), 2000);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const menu = document.getElementById('menu');
        if (!menu.classList.contains('closed')) {
           document.getElementById('toggle-btn').click();
        }
        closeAllAutocompletes();
      }
    });

    function focusOnNode(node) {
        const distance = 80;
        const distRatio = 1 + distance / Math.hypot(node.x || 0, node.y || 0, node.z || 0);
        const newPos = {
          x: (node.x || 0) * distRatio,
          y: (node.y || 0) * distRatio,
          z: (node.z || 0) * distRatio
        };
        Graph.cameraPosition(newPos, node, 1000);
        
        highlightNodes.clear();
        highlightLinks.clear();
        highlightNodes.add(node);
        node.neighbors.forEach(n => highlightNodes.add(n));
        node.links.forEach(l => highlightLinks.add(l));
        hoverNode = node;
        updateHighlight();
    }

    document.querySelectorAll('.search-box').forEach(searchBox => {
        const searchInput = searchBox.querySelector('.search-input');
        const autocompleteResults = searchBox.querySelector('.autocomplete-results');

        const performSearch = () => {
            const searchValue = searchInput.value.trim();
            const searchValueLower = searchValue.toLowerCase();

            const artistMatch = uniqueArtists.find(a => a.toLowerCase() === searchValueLower);
            if(artistMatch){
                highlightNodes.clear();
                highlightLinks.clear();
                const nodesByArtist = nodes.filter(n => n.author === artistMatch);
                const artistNodeSet = new Set(nodesByArtist);
                artistNodeSet.forEach(node => highlightNodes.add(node));
                links.forEach(link => {
                    if(artistNodeSet.has(link.source) && artistNodeSet.has(link.target)){
                        highlightLinks.add(link);
                    }
                });
                updateHighlight();
                closeAllAutocompletes();
                return;
            }

            const nodeByName = nodes.find(n => n.name.toLowerCase() === searchValueLower);
            if(nodeByName){
                focusOnNode(nodeByName);
                closeAllAutocompletes();
                return;
            }

            const nodeById = nodes.find(n => n.id.toString() === searchValue);
            if(nodeById){
                focusOnNode(nodeById);
                closeAllAutocompletes();
                return;
            }
            
            searchInput.value = '';
            searchInput.placeholder = 'No results found!';
            setTimeout(() => { searchInput.placeholder = 'Search piece or artist...'; }, 2000);
            closeAllAutocompletes();
        }

        searchInput.addEventListener('input', () => {
            const value = searchInput.value.toLowerCase();
            autocompleteResults.innerHTML = '';
            if (value.length === 0) {
                closeAllAutocompletes();
                return;
            }

            const matchingNodes = nodes
                .filter(node => node.name.toLowerCase().includes(value))
                .slice(0, 10);

            if (matchingNodes.length > 0) {
                matchingNodes.forEach(node => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `<b>${node.name}</b><small>by ${node.author}</small>`;
                    item.addEventListener('click', () => {
                        searchInput.value = node.name;
                        performSearch();
                    });
                    autocompleteResults.appendChild(item);
                });
                autocompleteResults.style.display = 'block';
            } else {
                closeAllAutocompletes();
            }
            autocompleteIndex = -1;
        });

        searchInput.addEventListener('keydown', (e) => {
            const items = autocompleteResults.getElementsByClassName('autocomplete-item');
            if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteIndex > -1) {
                    items[autocompleteIndex].click();
                } else {
                    performSearch();
                }
            } else if (items.length > 0) {
                if (e.key === 'ArrowDown') {
                    autocompleteIndex = (autocompleteIndex + 1) % items.length;
                    updateAutocompleteActive(items);
                } else if (e.key === 'ArrowUp') {
                    autocompleteIndex = (autocompleteIndex - 1 + items.length) % items.length;
                    updateAutocompleteActive(items);
                }
            }
        });
        
        const updateAutocompleteActive = (items) => {
            Array.from(items).forEach((item, index) => {
                item.classList.toggle('active', index === autocompleteIndex);
            });
        }

        searchBox.querySelector('.search-btn').addEventListener('click', performSearch);
    });

    document.querySelectorAll('.random-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            if (nodes.length > 0) {
                const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                if(randomNode) focusOnNode(randomNode);
            }
        });
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-box')) {
            closeAllAutocompletes();
        }
    });

    // Initialize App
    async function main() {
        const menu = document.getElementById('menu');
        const toggleBtn = document.getElementById('toggle-btn');
        if (window.innerWidth <= 768) {
            menu.classList.add('closed');
            toggleBtn.textContent = '☰';
        } else {
            toggleBtn.textContent = '×';
        }
        
        const graphData = await loadAndProcessGraphData();
        if (graphData) {
            nodes = graphData.nodes;
            links = graphData.links;
            adjacencyMatrix = graphData.adjacencyMatrix;
            communities = graphData.communities;
            colors = graphData.colors;
            initGraph();
            startTextureManagementLoop();
        }
    }

    window.addEventListener('load', main);
  </script>
</body>
</html>