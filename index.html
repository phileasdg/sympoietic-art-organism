<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet" />

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'DM Sans', system-ui, sans-serif;
      background: #0f1419;
      color: #c2d4d0;
      overflow: hidden;
      cursor: default;
    }

    /* Menu */
    #menu {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 12px;
      padding: 20px 26px;
      width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      transform-origin: top left;
    }

    #menu.closed {
      width: auto;
      padding: 16px 14px;
      flex-direction: row;
      align-items: center;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box,
    #menu.closed #community-section {
      display: none;
    }

    #title {
      font-size: 1.6rem;
      font-weight: 600;
      margin: 0;
      color: #c2d4d0;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: #7db8a8;
    }

    #subtitle {
      font-size: 0.95rem;
      line-height: 1.5;
      opacity: 0.85;
      color: #c2d4d0;
      margin: 0;
    }

    #nav-box {
      background: rgba(100, 140, 130, 0.06);
      border: 1px solid rgba(100, 140, 130, 0.12);
      border-radius: 8px;
      padding: 16px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    nav ul li a {
      color: #c2d4d0;
      text-decoration: none;
      font-weight: 500;
      font-size: 1.05rem;
      padding: 10px 16px;
      border-radius: 6px;
      display: block;
      transition: all 0.2s ease;
    }

    nav ul li a:hover {
      background: #7db8a8;
      color: #1a2a2e;
      transform: translateX(2px);
    }
    
    /* Community section */
    #community-section {
      background: rgba(100, 140, 130, 0.06);
      border: 1px solid rgba(100, 140, 130, 0.12);
      border-radius: 8px;
      padding: 16px;
    }

    #community-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: #c2d4d0;
    }

    #community-select {
      width: 100%;
      background: rgba(50, 70, 80, 0.8);
      border: 1px solid rgba(100, 140, 130, 0.2);
      border-radius: 8px;
      color: #c2d4d0;
      padding: 12px 16px;
      font-size: 0.95rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #community-select:hover {
      background: rgba(70, 90, 100, 0.8);
      border-color: rgba(100, 140, 130, 0.4);
    }

    #community-select:focus {
      outline: 2px solid #7db8a8;
      outline-offset: 2px;
    }

    #community-select option {
      background: #1a2a2e;
      color: #c2d4d0;
    }


    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.3rem;
      font-weight: 600;
      color: #c2d4d0;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 180px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* Buttons */
    button {
      background: rgba(50, 70, 80, 0.8);
      border: 1px solid rgba(100, 140, 130, 0.2);
      border-radius: 8px;
      color: #c2d4d0;
      cursor: pointer;
      padding: 12px 20px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      background: #7db8a8;
      color: #1a2a2e;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(0);
    }

    #toggle-btn {
      width: 44px;
      height: 44px;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    #toggle-btn:hover {
      transform: scale(1.05);
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 44px;
      height: 180px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 0.9rem;
      border-radius: 10px;
    }

    /* Copy confirmation */
    #copy-confirmation {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translate(-50%, 40px);
      background: #7db8a8;
      color: #1a2a2e;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    /* 3D graph container */
    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: radial-gradient(ellipse at center, #1a252f 0%, #0f1419 100%);
    }

    #graph-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(15, 20, 25, 0.6) 100%);
      z-index: 1;
      pointer-events: none;
    }
    
    /* Legend */
    #legend {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 99;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      max-width: 200px;
      display: none;
    }

    #legend.visible {
      display: block;
    }

    #legend-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: #c2d4d0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(100, 140, 130, 0.2);
    }

    .legend-label {
      color: #c2d4d0;
      font-weight: 500;
      text-transform: capitalize;
    }


    /* Breathing toggle button */
    #breathing-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 50%;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      color: #7db8a8;
    }

    #breathing-toggle:hover {
      background: rgba(30, 40, 50, 0.95);
      transform: scale(1.05);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
    }

    #breathing-toggle.active {
      background: #7db8a8;
      color: #1a2a2e;
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.4);
    }

    #breathing-toggle.active:hover {
      background: #8dc4b4;
    }

    /* Responsive improvements */
    @media (max-width: 768px) {
      #menu {
        width: calc(100vw - 32px);
        padding: 16px 20px;
        top: 16px;
        left: 16px;
      }

      #menu.closed {
        padding: 12px 10px;
        width: auto;
      }

      #breathing-toggle {
        bottom: 16px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 1.3rem;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* Focus states for keyboard navigation */
    button:focus,
    nav ul li a:focus {
      outline: 2px solid #7db8a8;
      outline-offset: 2px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <div id="community-section">
        <h3 id="community-title">Community View</h3>
        <select id="community-select">
          <option value="none">Default View</option>
          <option value="author">By Author</option>
          <option value="phase">By Project Phase</option>
        </select>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn" aria-label="Toggle menu">×</button>
      <button id="copy-btn">📋 Copy network<br>adjacency matrix</button>
    </div>
  </nav>

  <div id="copy-confirmation" role="alert" aria-live="polite">Copied!</div>
  <div id="legend">
    <h4 id="legend-title">Communities</h4>
    <div id="legend-items"></div>
  </div>
  <div id="breathing-toggle" title="Toggle organism breathing" aria-label="Toggle breathing animation" class="active">
    💨
  </div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // State
    let Graph;
    let nodes = [];
    let links = [];
    let adjacencyMatrix = [];
    let communities = {};
    let colors = {};
    let currentCommunityView = 'none';
    let isBreathing = true; // On by default
    let isEngineSettled = false;
    let breathingInterval = null;
    let hoverNode = null;
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    const nodeSprites = new Map();
    const proximityThreshold = 100; // Distance to trigger high-res load
    const thumbnailTextures = new Map();
    const highresTextures = new Map();

    // Helper to generate a color palette
    function generateColorPalette(keys) {
        const palette = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#FFA07A", "#98D8C8", "#F7DC6F", "#BB8FCE", "#F1948A"];
        const colorMap = {};
        keys.forEach((key, index) => {
            colorMap[key] = palette[index % palette.length];
        });
        return colorMap;
    }

    // Fetches and processes graph data from JSON files
    async function loadAndProcessGraphData() {
        try {
            const [verticesRes, edgesRes] = await Promise.all([
                fetch('./graph/vertices.json'),
                fetch('./graph/edges.json')
            ]);

            if (!verticesRes.ok || !edgesRes.ok) {
                throw new Error(`Failed to load graph data files. Status: Vertices ${verticesRes.status}, Edges ${edgesRes.status}`);
            }

            const verticesMap = await verticesRes.json();
            const edgesList = await edgesRes.json();
            
            const tempCommunities = { author: {}, phase: {} };
            const uniqueAuthors = new Set();
            const uniquePhases = new Set();

            // Build graph data
            const localNodes = Object.entries(verticesMap).map(([id, filename]) => {
                const parts = filename.split('-');
                const phase = `Phase ${parts[0]}`;
                const author = (parts[1] || 'Unknown').replace(/_/g, ' ');

                uniqueAuthors.add(author);
                uniquePhases.add(phase);

                if (!tempCommunities.author[author]) tempCommunities.author[author] = [];
                tempCommunities.author[author].push(parseInt(id, 10));

                if (!tempCommunities.phase[phase]) tempCommunities.phase[phase] = [];
                tempCommunities.phase[phase].push(parseInt(id, 10));

                return {
                    id: parseInt(id, 10),
                    img: `${filename}.jpeg`,
                    author,
                    phase,
                    neighbors: [],
                    links: [],
                    textureState: 'thumbnail'
                };
            });
            
            const tempColors = {
                author: generateColorPalette(Array.from(uniqueAuthors)),
                phase: generateColorPalette(Array.from(uniquePhases).sort())
            };


            const localLinks = edgesList.map(([source, target]) => ({
                source: parseInt(source, 10),
                target: parseInt(target, 10)
            }));
            
            const edgeSet = new Set(edgesList.map(([s, t]) => `${s},${t}`));

            localLinks.forEach(link => {
                const revLinkExists = edgeSet.has(`${link.target},${link.source}`);
                if (revLinkExists) {
                    link.curvature = link.source < link.target ? 0.4 : -0.4;
                    link.rotation = link.source < link.target ? 0 : Math.PI / 2;
                } else {
                    link.curvature = 0;
                    link.rotation = 0;
                }
            });

            const nodeMap = new Map(localNodes.map(node => [node.id, node]));
            localLinks.forEach(link => {
                const a = nodeMap.get(link.source);
                const b = nodeMap.get(link.target);
                if (a && b) {
                    a.neighbors.push(b);
                    b.neighbors.push(a);
                    a.links.push(link);
                    b.links.push(link);
                }
            });

            const nodeIds = localNodes.map(n => n.id);
            const maxId = Math.max(0, ...nodeIds);
            const localAdjacencyMatrix = Array(maxId + 1).fill(0).map(() => Array(maxId + 1).fill(0));
            edgesList.forEach(([source, target]) => {
                if (source <= maxId && target <= maxId) {
                    localAdjacencyMatrix[source][target] = 1;
                }
            });
            
            return { 
                nodes: localNodes, 
                links: localLinks, 
                adjacencyMatrix: localAdjacencyMatrix,
                communities: tempCommunities,
                colors: tempColors
            };
        } catch (error) {
            console.error("Error loading graph:", error);
            document.getElementById('3d-graph').innerHTML = `<div style="color: #ff6b6b; padding: 40px; text-align: center; font-size: 1.2rem;"><h2>Failed to Load Organism</h2><p>${error.message}</p><p>Please check the console for more details.</p></div>`;
            return null;
        }
    }

    // Helper functions
    function getNodeColor(node) {
      if (highlightNodes.has(node)) {
        return node === hoverNode ? '#A8E6A3' : '#C8F4C3';
      }
      
      if (currentCommunityView === 'none') return '#ffffff';
      
      const communityData = communities[currentCommunityView];
      const colorData = colors[currentCommunityView];
      
      if (communityData && colorData) {
        const key = node[currentCommunityView];
        if (key && colorData[key]) {
            return colorData[key];
        }
      }
      
      return '#ffffff';
    }

    function getLinkColor(link) {
        if (highlightLinks.has(link)) return '#7ED377';
        if (currentCommunityView === 'none' || !link.source.id || !link.target.id) return '#7db8a8';

        const communityData = communities[currentCommunityView];
        const colorData = colors[currentCommunityView];
        
        const sourceNode = nodes.find(n => n.id === link.source.id);
        const targetNode = nodes.find(n => n.id === link.target.id);
        
        if (sourceNode && targetNode && communityData && colorData) {
            const sourceCommunity = sourceNode[currentCommunityView];
            const targetCommunity = targetNode[currentCommunityView];
            
            if (sourceCommunity && targetCommunity) {
                return sourceCommunity === targetCommunity ? colorData[sourceCommunity] : '#FFA726'; // Orange for inter-community links
            }
        }
      
      return '#7db8a8';
    }

    function updateHighlight() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph
        .linkWidth(link => highlightLinks.has(link) ? 3 : 1.5)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0)
        .linkDirectionalArrowLength(link => highlightLinks.has(link) ? 12 : 8)
        .linkDirectionalArrowColor(link => highlightLinks.has(link) ? '#7ED377' : getLinkColor(link))
        .linkColor(getLinkColor);
    }

    // Breathing system
    function startBreathing() {
      if (breathingInterval || !isEngineSettled) return;
      
      let phase = 0;
      
      breathingInterval = setInterval(() => {
        phase += 0.02; // Adjust speed of the breathing cycle

        nodes.forEach(node => {
            if (!node.__threeObj) return;
            
            // Apply a noticeable scaling effect, timed with the breathing
            const scalePhase = phase + (node.id * 0.5); // Offset phase per node
            const scale = 25 * (1 + 0.4 * Math.sin(scalePhase)); // More pronounced scale variation
            node.__threeObj.scale.setScalar(scale);
        });

        // Fluctuate link width and opacity to create a "pulsing" or "breathing" effect through the connections.
        const pulseFactor = 1 + 0.9 * Math.sin(phase * 1.5); // More pronounced variation (0.1 to 1.9)
        Graph.linkWidth(link => (highlightLinks.has(link) ? 3 : 1.5) * pulseFactor);

        // Fluctuate link opacity with a slight phase shift from the width pulse for a more dynamic feel
        const linkOpacity = 0.65 + 0.2 * Math.sin(phase * 1.5 + Math.PI / 2);
        Graph.linkOpacity(Math.max(0.35, Math.min(0.85, linkOpacity)));

      }, 40);
    }

    function stopBreathing() {
      if (breathingInterval) {
        clearInterval(breathingInterval);
        breathingInterval = null;
      }
      
      // Reset nodes scale
      nodes.forEach(node => {
          if (node.__threeObj) {
              node.__threeObj.scale.setScalar(22);
          }
      });
      
      Graph.linkOpacity(0.8);
      updateHighlight(); // Resets link widths and other properties based on the current hover state.
    }
    
    // Dynamic Texture Loading System
    function manageDynamicTextures() {
        if (!Graph || !Graph.camera()) return;

        const cameraPosition = Graph.camera().position;

        nodes.forEach(node => {
            if (!node.__threeObj) return;

            const nodePosition = node.__threeObj.position;
            const distance = cameraPosition.distanceTo(nodePosition);

            if (distance < proximityThreshold) {
                if (node.textureState === 'thumbnail') {
                    node.textureState = 'loading_highres';

                    const highResUrl = `./art-imgs/${node.img}`;
                    new THREE.TextureLoader().load(
                        highResUrl,
                        (highResTexture) => {
                            highResTexture.colorSpace = THREE.SRGBColorSpace;
                            if (node.__threeObj) {
                                node.__threeObj.material.map = highResTexture;
                                highresTextures.set(node.id, highResTexture);
                                node.textureState = 'highres';
                            } else {
                               highResTexture.dispose();
                            }
                        },
                        undefined,
                        (error) => {
                            console.error(`Failed to load high-res image for node ${node.id}: ${highResUrl}`, error);
                            node.textureState = 'thumbnail';
                        }
                    );
                }
            } else {
                if (node.textureState === 'highres') {
                    const thumbnailTexture = thumbnailTextures.get(node.id);
                    if (thumbnailTexture && node.__threeObj) {
                        node.__threeObj.material.map = thumbnailTexture;
                    }

                    const highResTexture = highresTextures.get(node.id);
                    if (highResTexture) {
                        highResTexture.dispose();
                        highresTextures.delete(node.id);
                    }
                    node.textureState = 'thumbnail';
                }
            }
        });
    }

    function startTextureManagementLoop() {
        function animate() {
            manageDynamicTextures();
            requestAnimationFrame(animate);
        }
        animate();
    }


    // Initialize graph
    function initGraph() {
      Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .graphData({ nodes, links })
        .backgroundColor('rgba(0,0,0,0)')
        .nodeThreeObject(node => {
          const texture = new THREE.TextureLoader().load(
            `./art-thumbnails/${node.img}`,
            (texture) => {
              texture.colorSpace = THREE.SRGBColorSpace;
              thumbnailTextures.set(node.id, texture);
              const sprite = nodeSprites.get(node.id);
              if (sprite?.material) {
                sprite.material.color.set(getNodeColor(node));
                sprite.material.needsUpdate = true;
              }
            },
            undefined,
            (error) => {
              console.error(`Image failed for node ${node.id} (${node.img}):`, error);
              const sprite = nodeSprites.get(node.id);
              if (sprite) {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FF6B6B';
                ctx.fillRect(0, 0, 64, 64);
                sprite.material.map = new THREE.CanvasTexture(canvas);
                sprite.material.needsUpdate = true;
              }
            }
          );
          
          const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9,
            color: getNodeColor(node)
          });
          
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(22, 22, 1);
          nodeSprites.set(node.id, sprite);
          return sprite;
        })
        .nodeColor(() => null)
        .linkWidth(1.5)
        .linkDirectionalArrowLength(8)
        .linkDirectionalArrowRelPos(0.85)
        .linkColor(getLinkColor)
        .linkOpacity(0.8)
        .linkCurvature(link => link.curvature || 0)
        .linkCurveRotation(link => link.rotation || 0)
        .nodeLabel(node => {
          const fileName = node.img.split('/').pop().split('.')[0];
          let communityInfo = '';
          if (currentCommunityView !== 'none') {
              communityInfo = `<br><small style="text-transform: capitalize;">${node[currentCommunityView]}</small>`;
          }
          return `<div style="background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; color: #c2d4d0; font-size: 12px; font-weight: 500;">${fileName}${communityInfo}</div>`;
        })
        .onNodeHover(node => {
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          highlightNodes.clear();
          highlightLinks.clear();

          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(n => highlightNodes.add(n));
            node.links.forEach(l => highlightLinks.add(l));
          }

          hoverNode = node || null;
          updateHighlight();
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }

          updateHighlight();
        })
        .onNodeClick(node => {
          if (!node) return;
          const distance = 60;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
          const newPos = {
            x: node.x * distRatio,
            y: node.y * distRatio,
            z: node.z * distRatio
          };
          Graph.cameraPosition(newPos, node, 2000);
        })
        .onEngineStop(() => {
            console.log("Force engine stopped. Capturing natural positions.");
            nodes.forEach(node => {
                node.naturalX = node.x;
                node.naturalY = node.y;
                node.naturalZ = node.z;
            });
            isEngineSettled = true;

            if (isBreathing) {
                startBreathing();
            }
        });

      Graph.controls().enableDamping = true;
      Graph.controls().dampingFactor = 0.05;
    }
    
    // UI Event handlers
    function updateCommunityView() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph.linkColor(getLinkColor);
      
      // Update legend
      const legend = document.getElementById('legend');
      const legendItems = document.getElementById('legend-items');
      
      if (currentCommunityView === 'none') {
        legend.classList.remove('visible');
        return;
      }
      
      legend.classList.add('visible');
      legendItems.innerHTML = '';
      
      const colorData = colors[currentCommunityView];
      
      if (colorData) {
        Object.entries(colorData).forEach(([name, color]) => {
          const item = document.createElement('div');
          item.className = 'legend-item';
          
          const colorBox = document.createElement('div');
          colorBox.className = 'legend-color';
          colorBox.style.backgroundColor = color;
          
          const label = document.createElement('span');
          label.className = 'legend-label';
          label.textContent = name;
          
          item.appendChild(colorBox);
          item.appendChild(label);
          legendItems.appendChild(item);
        });
      }
    }


    // Event listeners
    document.getElementById('toggle-btn').addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const isOpen = !menu.classList.contains('closed');
      menu.classList.toggle('closed', isOpen);
      document.getElementById('toggle-btn').textContent = isOpen ? '☰' : '×';
    });

    document.getElementById('community-select').addEventListener('change', (e) => {
        currentCommunityView = e.target.value;
        updateCommunityView();
    });

    document.getElementById('breathing-toggle').addEventListener('click', () => {
      const toggle = document.getElementById('breathing-toggle');
      isBreathing = !isBreathing; // Toggle the state
      if (isBreathing) {
        startBreathing();
        toggle.classList.add('active');
      } else {
        stopBreathing();
        toggle.classList.remove('active');
      }
    });

    document.getElementById('copy-btn').addEventListener('click', async () => {
      const text = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
      }
      const confirm = document.getElementById('copy-confirmation');
      confirm.classList.add('visible');
      setTimeout(() => confirm.classList.remove('visible'), 2000);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const menu = document.getElementById('menu');
        if (!menu.classList.contains('closed')) {
           document.getElementById('toggle-btn').click();
        }
      }
    });

    // Initialize App
    async function main() {
        const graphData = await loadAndProcessGraphData();
        if (graphData) {
            nodes = graphData.nodes;
            links = graphData.links;
            adjacencyMatrix = graphData.adjacencyMatrix;
            communities = graphData.communities;
            colors = graphData.colors;
            initGraph();
            startTextureManagementLoop();
        }
    }

    window.addEventListener('load', main);
  </script>
</body>
</html>