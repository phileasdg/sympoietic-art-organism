<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet" />

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'DM Sans', system-ui, sans-serif;
      background: #0f1419;
      color: #c2d4d0;
      overflow: hidden;
      cursor: default;
    }

    /* Menu */
    #menu {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 12px;
      padding: 20px 26px;
      width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      transform-origin: top left;
    }

    #menu.closed {
      width: auto;
      padding: 16px 14px;
      flex-direction: row;
      align-items: center;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box {
      display: none;
    }

    #title {
      font-size: 1.6rem;
      font-weight: 600;
      margin: 0;
      color: #c2d4d0;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: #7db8a8;
    }

    #subtitle {
      font-size: 0.95rem;
      line-height: 1.5;
      opacity: 0.85;
      color: #c2d4d0;
      margin: 0;
    }

    #nav-box {
      background: rgba(100, 140, 130, 0.06);
      border: 1px solid rgba(100, 140, 130, 0.12);
      border-radius: 8px;
      padding: 16px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    nav ul li a {
      color: #c2d4d0;
      text-decoration: none;
      font-weight: 500;
      font-size: 1.05rem;
      padding: 10px 16px;
      border-radius: 6px;
      display: block;
      transition: all 0.2s ease;
    }

    nav ul li a:hover {
      background: #7db8a8;
      color: #1a2a2e;
      transform: translateX(2px);
    }

    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.3rem;
      font-weight: 600;
      color: #c2d4d0;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 180px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* Buttons */
    button {
      background: rgba(50, 70, 80, 0.8);
      border: 1px solid rgba(100, 140, 130, 0.2);
      border-radius: 8px;
      color: #c2d4d0;
      cursor: pointer;
      padding: 12px 20px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      background: #7db8a8;
      color: #1a2a2e;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(0);
    }

    #toggle-btn {
      width: 44px;
      height: 44px;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    #toggle-btn:hover {
      transform: scale(1.05);
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 44px;
      height: 180px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 0.9rem;
      border-radius: 10px;
    }

    /* Copy confirmation */
    #copy-confirmation {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translate(-50%, 40px);
      background: #7db8a8;
      color: #1a2a2e;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    /* 3D graph container */
    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: radial-gradient(ellipse at center, #1a252f 0%, #0f1419 100%);
    }

    #graph-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(15, 20, 25, 0.6) 100%);
      z-index: 1;
      pointer-events: none;
    }

    /* Breathing toggle button */
    #breathing-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 50%;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      color: #7db8a8;
    }

    #breathing-toggle:hover {
      background: rgba(30, 40, 50, 0.95);
      transform: scale(1.05);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
    }

    #breathing-toggle.active {
      background: #7db8a8;
      color: #1a2a2e;
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.4);
    }

    #breathing-toggle.active:hover {
      background: #8dc4b4;
    }

    /* Responsive improvements */
    @media (max-width: 768px) {
      #menu {
        width: calc(100vw - 32px);
        padding: 16px 20px;
        top: 16px;
        left: 16px;
      }

      #menu.closed {
        padding: 12px 10px;
        width: auto;
      }

      #breathing-toggle {
        bottom: 16px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 1.3rem;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* Focus states for keyboard navigation */
    button:focus,
    nav ul li a:focus {
      outline: 2px solid #7db8a8;
      outline-offset: 2px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn" aria-label="Toggle menu">Ã—</button>
      <button id="copy-btn">ðŸ“‹ Copy network<br>adjacency matrix</button>
    </div>
  </nav>

  <div id="copy-confirmation" role="alert" aria-live="polite">Copied!</div>
  <div id="breathing-toggle" title="Toggle organism breathing" aria-label="Toggle breathing animation">
    ðŸ’¨
  </div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // State
    let Graph;
    let nodes = [];
    let links = [];
    let adjacencyMatrix = [];
    let isBreathing = false;
    let breathingInterval = null;
    let hoverNode = null;
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    const nodeSprites = new Map();

    // Fetches and processes graph data from JSON files
    async function loadAndProcessGraphData() {
        try {
            const [verticesRes, edgesRes] = await Promise.all([
                fetch('./graph/vertices.json'),
                fetch('./graph/edges.json')
            ]);

            if (!verticesRes.ok || !edgesRes.ok) {
                throw new Error(`Failed to load graph data files. Status: Vertices ${verticesRes.status}, Edges ${edgesRes.status}`);
            }

            const verticesMap = await verticesRes.json();
            const edgesList = await edgesRes.json();

            // Build graph data
            const localNodes = Object.entries(verticesMap).map(([id, filename]) => ({
                id: parseInt(id, 10),
                img: `${filename}.jpeg`,
                neighbors: [],
                links: []
            }));

            const localLinks = edgesList.map(([source, target]) => ({
                source: parseInt(source, 10),
                target: parseInt(target, 10)
            }));
            
            // Create a set of stringified edges for quick curvature calculation
            const edgeSet = new Set(edgesList.map(([s, t]) => `${s},${t}`));

            localLinks.forEach(link => {
                const revLinkExists = edgeSet.has(`${link.target},${link.source}`);
                if (revLinkExists) {
                    link.curvature = link.source < link.target ? 0.4 : -0.4;
                    link.rotation = link.source < link.target ? 0 : Math.PI / 2;
                } else {
                    link.curvature = 0;
                    link.rotation = 0;
                }
            });

            // Populate neighbors and links for highlighting logic
            const nodeMap = new Map(localNodes.map(node => [node.id, node]));
            localLinks.forEach(link => {
                const a = nodeMap.get(link.source);
                const b = nodeMap.get(link.target);
                if (a && b) {
                    a.neighbors.push(b);
                    b.neighbors.push(a);
                    a.links.push(link);
                    b.links.push(link);
                }
            });

            // Generate adjacency matrix for copy functionality
            const nodeIds = localNodes.map(n => n.id);
            const maxId = Math.max(0, ...nodeIds);
            const localAdjacencyMatrix = Array(maxId).fill(0).map(() => Array(maxId).fill(0));
            edgesList.forEach(([source, target]) => {
                // Adjacency matrix is 1-based, array is 0-based
                if (source > 0 && source <= maxId && target > 0 && target <= maxId) {
                    localAdjacencyMatrix[source - 1][target - 1] = 1;
                }
            });

            return { nodes: localNodes, links: localLinks, adjacencyMatrix: localAdjacencyMatrix };
        } catch (error) {
            console.error("Error loading graph:", error);
            document.getElementById('3d-graph').innerHTML = `<div style="color: #ff6b6b; padding: 40px; text-align: center; font-size: 1.2rem;"><h2>Failed to Load Organism</h2><p>${error.message}</p><p>Please check the console for more details.</p></div>`;
            return null;
        }
    }

    // Helper functions
    function getNodeColor(node) {
      if (highlightNodes.has(node)) {
        return node === hoverNode ? '#A8E6A3' : '#C8F4C3';
      }
      return '#ffffff';
    }

    function getLinkColor(link) {
      if (highlightLinks.has(link)) return '#7ED377';
      return '#7db8a8';
    }

    function updateHighlight() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph
        .linkWidth(link => highlightLinks.has(link) ? 3 : 1.5)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0)
        .linkDirectionalArrowLength(link => highlightLinks.has(link) ? 12 : 8)
        .linkDirectionalArrowColor(link => highlightLinks.has(link) ? '#7ED377' : getLinkColor(link))
        .linkColor(getLinkColor);
    }

    // Breathing system
    function startBreathing() {
      if (breathingInterval) return;
      
      let phase = 0;
      const nodeData = new Map();
      
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node && sprite) {
          const connectionCount = node.neighbors.length;
          const wavePhase = (nodeId * 0.8 + connectionCount * 0.3) * Math.PI / 4;
          nodeData.set(nodeId, { sprite, wavePhase });
        }
      });

      breathingInterval = setInterval(() => {
        phase += 0.015;
        
        nodeData.forEach(({ sprite, wavePhase }) => {
          const nodePhase = phase + wavePhase;
          const scale = 22 * (1 + 0.25 * Math.sin(nodePhase));
          sprite.scale.setScalar(scale);
        });

        const linkOpacity = 0.65 + 0.2 * (
          Math.sin(phase * 0.8) * 0.3 + 
          Math.sin(phase * 1.2) * 0.4 + 
          Math.sin(phase * 0.6) * 0.3
        );
        Graph.linkOpacity(Math.max(0.4, Math.min(0.9, linkOpacity)));
      }, 40);
    }

    function stopBreathing() {
      if (breathingInterval) {
        clearInterval(breathingInterval);
        breathingInterval = null;
      }
      
      nodeSprites.forEach(sprite => {
        if (sprite) sprite.scale.setScalar(22);
      });
      
      Graph.linkOpacity(0.8);
    }

    // Initialize graph
    function initGraph() {
      Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .graphData({ nodes, links })
        .backgroundColor('rgba(0,0,0,0)')
        .nodeThreeObject(node => {
          const texture = new THREE.TextureLoader().load(
            `./art-thumbnails/${node.img}`,
            (texture) => { // Success
              texture.colorSpace = THREE.SRGBColorSpace;
              const sprite = nodeSprites.get(node.id);
              if (sprite?.material) {
                sprite.material.color.set(getNodeColor(node));
                sprite.material.needsUpdate = true;
              }
            },
            undefined, // Progress
            (error) => { // Error
              console.error(`Image failed for node ${node.id} (${node.img}):`, error);
              const sprite = nodeSprites.get(node.id);
              if (sprite) {
                const canvas = document.createElement('canvas');
                canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FF6B6B'; // Error color
                ctx.fillRect(0, 0, 64, 64);
                sprite.material.map = new THREE.CanvasTexture(canvas);
                sprite.material.needsUpdate = true;
              }
            }
          );
          
          const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9,
            color: getNodeColor(node)
          });
          
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(22, 22, 1);
          nodeSprites.set(node.id, sprite);
          return sprite;
        })
        .nodeColor(() => null)
        .linkWidth(1.5)
        .linkDirectionalArrowLength(8)
        .linkDirectionalArrowRelPos(0.85)
        .linkColor(getLinkColor)
        .linkOpacity(0.8)
        .linkCurvature(link => link.curvature || 0)
        .linkCurveRotation(link => link.rotation || 0)
        .nodeLabel(node => {
          const fileName = node.img.split('/').pop().split('.')[0];
          return `<div style="background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; color: #c2d4d0; font-size: 12px; font-weight: 500;">${fileName}</div>`;
        })
        .onNodeHover(node => {
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          highlightNodes.clear();
          highlightLinks.clear();

          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(n => highlightNodes.add(n));
            node.links.forEach(l => highlightLinks.add(l));
          }

          hoverNode = node || null;
          updateHighlight();
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }

          updateHighlight();
        })
        .onNodeClick(node => {
          if (!node) return;
          const distance = 60;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
          const newPos = {
            x: node.x * distRatio,
            y: node.y * distRatio,
            z: node.z * distRatio
          };
          Graph.cameraPosition(newPos, node, 2000);
        });

      Graph.controls().enableDamping = true;
      Graph.controls().dampingFactor = 0.05;
    }

    // Event listeners
    document.getElementById('toggle-btn').addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const isOpen = !menu.classList.contains('closed');
      menu.classList.toggle('closed', isOpen);
      document.getElementById('toggle-btn').textContent = isOpen ? 'â˜°' : 'Ã—';
    });

    document.getElementById('breathing-toggle').addEventListener('click', () => {
      const toggle = document.getElementById('breathing-toggle');
      isBreathing = !isBreathing;
      if (isBreathing) {
        startBreathing();
        toggle.classList.add('active');
      } else {
        stopBreathing();
        toggle.classList.remove('active');
      }
    });

    document.getElementById('copy-btn').addEventListener('click', async () => {
      const text = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        // Fallback for older browsers or insecure contexts
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
      }
      const confirm = document.getElementById('copy-confirmation');
      confirm.classList.add('visible');
      setTimeout(() => confirm.classList.remove('visible'), 2000);
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const menu = document.getElementById('menu');
        if (!menu.classList.contains('closed')) {
           document.getElementById('toggle-btn').click();
        }
      }
    });

    // Initialize App
    async function main() {
        const graphData = await loadAndProcessGraphData();
        if (graphData) {
            nodes = graphData.nodes;
            links = graphData.links;
            adjacencyMatrix = graphData.adjacencyMatrix;
            initGraph();
        }
    }

    window.addEventListener('load', main);
  </script>
</body>
</html>
