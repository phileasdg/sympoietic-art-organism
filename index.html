<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet" />

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'DM Sans', system-ui, sans-serif;
      background: #0f1419;
      color: #c2d4d0;
      overflow: hidden;
      cursor: default;
    }

    /* Menu */
    #menu {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 12px;
      padding: 20px 26px;
      width: 420px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      transform-origin: top left;
    }

    #menu.closed {
      width: auto;
      padding: 16px 14px;
      flex-direction: row;
      align-items: center;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box,
    #menu.closed #community-section {
      display: none;
    }

    #title {
      font-size: 1.6rem;
      font-weight: 600;
      margin: 0;
      color: #c2d4d0;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: #7db8a8;
    }

    #subtitle {
      font-size: 0.95rem;
      line-height: 1.5;
      opacity: 0.85;
      color: #c2d4d0;
      margin: 0;
    }

    #nav-box {
      background: rgba(100, 140, 130, 0.06);
      border: 1px solid rgba(100, 140, 130, 0.12);
      border-radius: 8px;
      padding: 16px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    nav ul li a {
      color: #c2d4d0;
      text-decoration: none;
      font-weight: 500;
      font-size: 1.05rem;
      padding: 10px 16px;
      border-radius: 6px;
      display: block;
      transition: all 0.2s ease;
    }

    nav ul li a:hover {
      background: #7db8a8;
      color: #1a2a2e;
      transform: translateX(2px);
    }

    /* Community section */
    #community-section {
      background: rgba(100, 140, 130, 0.06);
      border: 1px solid rgba(100, 140, 130, 0.12);
      border-radius: 8px;
      padding: 16px;
    }

    #community-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: #c2d4d0;
    }

    #community-select {
      width: 100%;
      background: rgba(50, 70, 80, 0.8);
      border: 1px solid rgba(100, 140, 130, 0.2);
      border-radius: 8px;
      color: #c2d4d0;
      padding: 12px 16px;
      font-size: 0.95rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #community-select:hover {
      background: rgba(70, 90, 100, 0.8);
      border-color: rgba(100, 140, 130, 0.4);
    }

    #community-select:focus {
      outline: 2px solid #7db8a8;
      outline-offset: 2px;
    }

    #community-select option {
      background: #1a2a2e;
      color: #c2d4d0;
    }

    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.3rem;
      font-weight: 600;
      color: #c2d4d0;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 180px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* Buttons */
    button {
      background: rgba(50, 70, 80, 0.8);
      border: 1px solid rgba(100, 140, 130, 0.2);
      border-radius: 8px;
      color: #c2d4d0;
      cursor: pointer;
      padding: 12px 20px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      background: #7db8a8;
      color: #1a2a2e;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    button:active {
      transform: translateY(0);
    }

    #toggle-btn {
      width: 44px;
      height: 44px;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s ease;
    }

    #toggle-btn:hover {
      transform: scale(1.05);
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 44px;
      height: 180px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 0.9rem;
      border-radius: 10px;
    }

    /* Copy confirmation */
    #copy-confirmation {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translate(-50%, 40px);
      background: #7db8a8;
      color: #1a2a2e;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    /* 3D graph container */
    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: radial-gradient(ellipse at center, #1a252f 0%, #0f1419 100%);
    }

    #graph-overlay {
      position: fixed;
      inset: 0;
      background: 
        radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(15, 20, 25, 0.6) 100%);
      z-index: 1;
      pointer-events: none;
    }

    /* Legend */
    #legend {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 99;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      max-width: 200px;
      display: none;
    }

    #legend.visible {
      display: block;
    }

    #legend-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: #c2d4d0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 0.85rem;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(100, 140, 130, 0.2);
    }

    .legend-label {
      color: #c2d4d0;
      font-weight: 500;
    }

    /* Breathing toggle button */
    #breathing-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(20, 30, 40, 0.90);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(100, 140, 130, 0.15);
      border-radius: 50%;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      color: #7db8a8;
    }

    #breathing-toggle:hover {
      background: rgba(30, 40, 50, 0.95);
      transform: scale(1.05);
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
    }

    #breathing-toggle.active {
      background: #7db8a8;
      color: #1a2a2e;
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.4);
    }

    #breathing-toggle.active:hover {
      background: #8dc4b4;
    }

    /* Responsive improvements */
    @media (max-width: 768px) {
      #menu {
        width: calc(100vw - 40px);
        padding: 16px 20px;
        top: 16px;
        left: 16px;
      }

      #menu.closed {
        padding: 12px 10px;
        width: auto;
      }

      #breathing-toggle {
        bottom: 16px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 1.3rem;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* Focus states for keyboard navigation */
    button:focus,
    nav ul li a:focus {
      outline: 2px solid #7db8a8;
      outline-offset: 2px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <div id="community-section">
      <h3 id="community-title">Community View</h3>
      <select id="community-select">
        <option value="none">Default View</option>
        <option value="artists">By Artist</option>
        <option value="artMedium">By Art Medium</option>
        <option value="timeCreated">By Time Created</option>
        <option value="connectionLevel">By Connection Level</option>
      </select>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn" aria-label="Toggle menu">×</button>
      <button id="copy-btn">📋 Copy network<br>adjacency matrix</button>
    </div>
  </nav>

  <div id="copy-confirmation" role="alert" aria-live="polite">Copied!</div>
  <div id="legend">
    <h4 id="legend-title">Communities</h4>
    <div id="legend-items"></div>
  </div>
  <div id="breathing-toggle" title="Toggle organism breathing" aria-label="Toggle breathing animation">
    💨
  </div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // Data
    const adjacencyMatrix = [
      [0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0],
      [0,0,0,1,0,0,1,0,0,1,0,1,1,1,0,0,0],
      [0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,1,1],
      [0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0],
      [0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0],
      [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    const imgs = [
      '0-Emerson_Paquette-1.png', '0-Emerson_Paquette-2.jpeg', '0-Emerson_Paquette-3.jpeg',
      '0-Emerson_Paquette-4.jpeg', '0-Emerson_Paquette-5.jpeg', '0-Emerson_Paquette-6.jpeg',
      '0-Emerson_Paquette-7.jpeg', '0-Phileas_Dazeley_Gaist-1.png', '0-Phileas_Dazeley_Gaist-2.png',
      '0-Phileas_Dazeley_Gaist-3.png', '0-Phileas_Dazeley_Gaist-4.png', '0-Phileas_Dazeley_Gaist-5.png',
      '0-Phileas_Dazeley_Gaist-6.png', '0-Phileas_Dazeley_Gaist-7.png', '0-Phileas_Dazeley_Gaist-8.png',
      '0-Phileas_Dazeley_Gaist-9.png', '0-Phileas_Dazeley_Gaist-10.png'
    ];

    // Community definitions
    const communities = {
      artists: {
        "emerson": [0, 1, 2, 3, 4, 5, 6],
        "phileas": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
      },
      artMedium: {
        "photography": [0, 2, 7, 9, 12],
        "digital": [1, 3, 8, 10, 14, 15],
        "mixed": [4, 5, 6, 11, 13, 16]
      },
      timeCreated: {
        "early": [0, 1, 7, 8],
        "middle": [2, 3, 4, 9, 10, 11],
        "recent": [5, 6, 12, 13, 14, 15, 16]
      },
      connectionLevel: {
        "highly_connected": [1, 2, 6, 9],
        "moderately_connected": [0, 3, 7, 10, 15],
        "lightly_connected": [4, 5, 8, 11, 12, 13, 14, 16]
      }
    };

    const colors = {
      artists: { "emerson": "#FF6B6B", "phileas": "#4ECDC4" },
      artMedium: { "photography": "#FF6B6B", "digital": "#4ECDC4", "mixed": "#FFA726" },
      timeCreated: { "early": "#9C27B0", "middle": "#2196F3", "recent": "#4CAF50" },
      connectionLevel: { "highly_connected": "#F44336", "moderately_connected": "#FF9800", "lightly_connected": "#8BC34A" }
    };

    // State
    let Graph;
    let currentCommunityView = 'none';
    let isBreathing = false; // Start with breathing off by default
    let breathingInterval = null;
    let hoverNode = null;
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    const nodeSprites = new Map();

    // Build graph data
    const nodes = imgs.map((img, id) => ({ id, img, neighbors: [], links: [] }));
    const links = [];
    
    for (let i = 0; i < adjacencyMatrix.length; i++) {
      for (let j = 0; j < adjacencyMatrix[i].length; j++) {
        if (adjacencyMatrix[i][j]) {
          const link = { source: i, target: j };
          
          // Calculate curvature for bidirectional links
          const revExists = adjacencyMatrix[j] && adjacencyMatrix[j][i];
          if (revExists) {
            link.curvature = i < j ? 0.4 : -0.4;
            link.rotation = i < j ? 0 : Math.PI / 2;
          } else {
            link.curvature = 0;
            link.rotation = 0;
          }
          
          links.push(link);
          nodes[i].neighbors.push(nodes[j]);
          nodes[j].neighbors.push(nodes[i]);
          nodes[i].links.push(link);
          nodes[j].links.push(link);
        }
      }
    }

    // Helper functions
    function getNodeColor(node) {
      if (highlightNodes.has(node)) {
        return node === hoverNode ? '#A8E6A3' : '#C8F4C3';
      }
      
      if (currentCommunityView === 'none') return '#ffffff';
      
      const communityData = communities[currentCommunityView];
      const colorData = colors[currentCommunityView];
      
      if (communityData && colorData) {
        for (const [name, nodeList] of Object.entries(communityData)) {
          if (nodeList.includes(node.id)) return colorData[name];
        }
      }
      
      return '#ffffff';
    }

    function getLinkColor(link) {
      if (highlightLinks.has(link)) return '#7ED377';
      if (currentCommunityView === 'none') return '#7db8a8';
      
      const communityData = communities[currentCommunityView];
      const colorData = colors[currentCommunityView];
      
      if (communityData && colorData) {
        let sourceCommunity = null;
        let targetCommunity = null;
        
        for (const [name, nodeList] of Object.entries(communityData)) {
          if (nodeList.includes(link.source)) sourceCommunity = name;
          if (nodeList.includes(link.target)) targetCommunity = name;
        }
        
        if (sourceCommunity && targetCommunity) {
          return sourceCommunity === targetCommunity ? colorData[sourceCommunity] : '#FFA726';
        }
      }
      
      return '#7db8a8';
    }

    function updateHighlight() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph
        .linkWidth(link => highlightLinks.has(link) ? 3 : 1.5)
        .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0)
        .linkDirectionalArrowLength(link => highlightLinks.has(link) ? 12 : 8)
        .linkDirectionalArrowColor(link => highlightLinks.has(link) ? '#7ED377' : getLinkColor(link))
        .linkColor(getLinkColor);
    }

    // Breathing system
    function startBreathing() {
      if (breathingInterval) return;
      
      let phase = 0;
      const nodeData = new Map();
      
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        if (node && sprite) {
          const connectionCount = node.neighbors.length;
          const wavePhase = (nodeId * 0.8 + connectionCount * 0.3) * Math.PI / 4;
          nodeData.set(nodeId, { sprite, wavePhase });
        }
      });

      breathingInterval = setInterval(() => {
        phase += 0.015;
        
        nodeData.forEach(({ sprite, wavePhase }) => {
          const nodePhase = phase + wavePhase;
          const scale = 22 * (1 + 0.25 * Math.sin(nodePhase));
          sprite.scale.setScalar(scale);
        });

        const linkOpacity = 0.65 + 0.2 * (
          Math.sin(phase * 0.8) * 0.3 + 
          Math.sin(phase * 1.2) * 0.4 + 
          Math.sin(phase * 0.6) * 0.3
        );
        Graph.linkOpacity(Math.max(0.4, Math.min(0.9, linkOpacity)));
      }, 40);
    }

    function stopBreathing() {
      if (breathingInterval) {
        clearInterval(breathingInterval);
        breathingInterval = null;
      }
      
      nodeSprites.forEach(sprite => {
        if (sprite) sprite.scale.setScalar(22);
      });
      
      Graph.linkOpacity(0.8);
    }

    // Initialize graph
    function initGraph() {
      Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .graphData({ nodes, links })
        .backgroundColor('rgba(0,0,0,0)')
        .nodeThreeObject(node => {
          const texture = new THREE.TextureLoader().load(
            `./art-thumbnails/${node.img}`,
            // Success callback
            (texture) => {
              texture.colorSpace = THREE.SRGBColorSpace;
              const sprite = nodeSprites.get(node.id);
              if (sprite?.material) {
                sprite.material.color.set(getNodeColor(node));
                sprite.material.needsUpdate = true;
              }
            },
            // Progress callback
            undefined,
            // Error callback - create colored fallback
            (error) => {
              console.log(`Image failed for node ${node.id}, using colored fallback`);
              const canvas = document.createElement('canvas');
              canvas.width = 64;
              canvas.height = 64;
              const ctx = canvas.getContext('2d');
              ctx.fillStyle = getNodeColor(node);
              ctx.fillRect(0, 0, 64, 64);
              
              const colorTexture = new THREE.CanvasTexture(canvas);
              const sprite = nodeSprites.get(node.id);
              if (sprite) {
                sprite.material.map = colorTexture;
                sprite.material.needsUpdate = true;
              }
            }
          );
          
          const material = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: 0.9,
            color: getNodeColor(node)
          });
          
          const sprite = new THREE.Sprite(material);
          sprite.scale.set(22, 22, 1);
          nodeSprites.set(node.id, sprite);
          return sprite;
        })
        .nodeColor(() => null)
        .linkWidth(1.5)
        .linkDirectionalArrowLength(8)
        .linkDirectionalArrowRelPos(0.85)
        .linkColor(getLinkColor)
        .linkOpacity(0.8)
        .linkCurvature(link => link.curvature || 0)
        .linkCurveRotation(link => link.rotation || 0)
        .nodeLabel(node => {
          const fileName = node.img.split('/').pop().split('.')[0];
          let communityInfo = '';
          
          if (currentCommunityView !== 'none') {
            const communityData = communities[currentCommunityView];
            if (communityData) {
              for (const [name, nodeList] of Object.entries(communityData)) {
                if (nodeList.includes(node.id)) {
                  communityInfo = `<br><small>${name.replace('_', ' ')}</small>`;
                  break;
                }
              }
            }
          }
          
          return `<div style="background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; color: #c2d4d0; font-size: 12px; font-weight: 500;">${fileName}${communityInfo}</div>`;
        })
        .onNodeHover(node => {
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          highlightNodes.clear();
          highlightLinks.clear();

          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(n => highlightNodes.add(n));
            node.links.forEach(l => highlightLinks.add(l));
          }

          hoverNode = node || null;
          updateHighlight();
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }

          updateHighlight();
        })
        .onNodeClick(node => {
          if (!node) return;
          const distance = 60;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
          const newPos = {
            x: node.x * distRatio,
            y: node.y * distRatio,
            z: node.z * distRatio
          };
          Graph.cameraPosition(newPos, node, 2000);
        })
        .onEngineStop(() => {
          // Graph is ready but breathing starts off by default
        });

      Graph.controls().enableDamping = true;
      Graph.controls().dampingFactor = 0.05;
    }

    // UI Event handlers
    function updateCommunityView() {
      nodeSprites.forEach((sprite, nodeId) => {
        const node = nodes.find(n => n.id === nodeId);
        const color = getNodeColor(node);
        if (sprite?.material) {
          sprite.material.color.set(color);
          sprite.material.needsUpdate = true;
        }
      });

      Graph.linkColor(getLinkColor);
      
      // Update legend
      const legend = document.getElementById('legend');
      const legendItems = document.getElementById('legend-items');
      
      if (currentCommunityView === 'none') {
        legend.classList.remove('visible');
        return;
      }
      
      legend.classList.add('visible');
      legendItems.innerHTML = '';
      
      const communityData = communities[currentCommunityView];
      const colorData = colors[currentCommunityView];
      
      if (communityData && colorData) {
        Object.entries(communityData).forEach(([name, nodeList]) => {
          const item = document.createElement('div');
          item.className = 'legend-item';
          
          const colorBox = document.createElement('div');
          colorBox.className = 'legend-color';
          colorBox.style.backgroundColor = colorData[name];
          
          const label = document.createElement('span');
          label.className = 'legend-label';
          label.textContent = name.replace('_', ' ');
          
          item.appendChild(colorBox);
          item.appendChild(label);
          legendItems.appendChild(item);
        });
      }
    }

    // Event listeners
    document.getElementById('toggle-btn').addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const isOpen = !menu.classList.contains('closed');
      menu.classList.toggle('closed', isOpen);
      document.getElementById('toggle-btn').textContent = isOpen ? '☰' : '×';
    });

    document.getElementById('community-select').addEventListener('change', (e) => {
      currentCommunityView = e.target.value;
      updateCommunityView();
    });

    document.getElementById('breathing-toggle').addEventListener('click', () => {
      const toggle = document.getElementById('breathing-toggle');
      if (isBreathing) {
        stopBreathing();
        isBreathing = false;
        toggle.classList.remove('active');
      } else {
        isBreathing = true;
        startBreathing();
        toggle.classList.add('active');
      }
    });

    document.getElementById('copy-btn').addEventListener('click', async () => {
      try {
        const text = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
        await navigator.clipboard.writeText(text);
        
        const confirm = document.getElementById('copy-confirmation');
        confirm.classList.add('visible');
        setTimeout(() => confirm.classList.remove('visible'), 2000);
      } catch (err) {
        const textArea = document.createElement('textarea');
        textArea.value = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        const confirm = document.getElementById('copy-confirmation');
        confirm.classList.add('visible');
        setTimeout(() => confirm.classList.remove('visible'), 2000);
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const menu = document.getElementById('menu');
        if (menu.classList.contains('closed')) {
          document.getElementById('toggle-btn').click();
        }
      }
    });

    // Initialize
    window.addEventListener('load', () => {
      setTimeout(initGraph, 100);
    });
  </script>
</body>
</html>