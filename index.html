<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-K13VH578CQ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-K13VH578CQ');
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet" />

  <style>
    :root {
      --font-sans: 'DM Sans', system-ui, sans-serif;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --bg-dark: #0f1419;
      --surface-1: rgba(20, 30, 40, 0.75);
      --surface-2: rgba(15, 23, 32, 0.9);
      --border-color: rgba(255, 255, 255, 0.1);
      --accent: #7db8a8;
      --accent-dark: #1a2a2e;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-sans);
      background-color: var(--bg-dark);
      color: var(--text-primary);
      overflow: hidden;
      cursor: default;
    }

    /* Menu */
    #menu {
      position: fixed;
      top: 20px;
      left: 20px;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 20px 26px;
      width: 420px;
      max-width: calc(100vw - 40px);
      display: flex;
      flex-direction: column;
      gap: 16px;
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      transition: all 0.3s ease;
      transform-origin: top left;
      max-height: calc(100vh - 40px);
      overflow-y: auto;
    }

    #menu.closed {
      width: auto;
      padding: 16px 14px;
      flex-direction: row;
      align-items: center;
      overflow-y: hidden;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box,
    #menu.closed #community-section {
      display: none;
    }

    #title {
      font-size: 1.8rem;
      font-weight: 600;
      margin: 0;
      color: var(--text-primary);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: var(--accent);
    }

    #subtitle {
      font-size: 0.95rem;
      line-height: 1.6;
      opacity: 0.85;
      color: var(--text-secondary);
      margin: 0;
    }

    #nav-box {
      background: rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 16px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    nav ul li a {
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 500;
      font-size: 1.05rem;
      padding: 10px 16px;
      border-radius: 6px;
      display: block;
      transition: all 0.2s ease;
    }

    nav ul li a:hover {
      background: var(--accent);
      color: var(--accent-dark);
      transform: translateX(2px);
    }
    
    /* Community Section */
    #community-section {
      background: rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 16px;
    }

    #community-title, #search-title, #cycle-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: var(--text-primary);
    }

    #community-select {
      width: 100%;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      padding: 12px 16px;
      font-size: 0.95rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    #community-select:hover {
      border-color: rgba(255, 255, 255, 0.2);
    }

    #community-select:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    #community-select option {
      background: var(--surface-2);
      color: var(--text-primary);
    }
    
    /* Timeline Controls */
    #cycle-section {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 99;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 12px 24px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      display: flex;
      align-items: center;
      gap: 24px;
    }
    
    #cycle-section h3 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      white-space: nowrap;
    }

    #cycle-slider-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 0;
      width: 220px;
    }
    #cycle-slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }
    #cycle-slider {
      width: 100%;
      cursor: pointer;
    }

    #cycle-toggles-title {
      display: none;
    }

    #cycle-toggles {
      display: flex;
      gap: 12px;
      align-items: center;
      border-left: 1px solid var(--border-color);
      padding-left: 24px;
    }

    .cycle-toggle-label {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(0,0,0,0.2);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .cycle-toggle-label:hover {
        background: rgba(255,255,255,0.1);
    }
    .cycle-toggle-label input {
        cursor: pointer;
    }


    /* Search Section */
    /* This is the search bar for desktop screens */
    .desktop-search {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 100;
        width: 300px;
    }

    .search-box {
        position: relative;
        display: flex;
        align-items: center;
        gap: 4px;
        transition: border-color 0.3s ease;
        border: 1px solid var(--border-color);
        border-radius: 12px;
        background: var(--surface-1);
        backdrop-filter: blur(12px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
        padding: 4px;
    }
    .search-box:focus-within {
        border-color: var(--accent);
    }


    .search-input {
      flex-grow: 1;
      background: transparent;
      border: none;
      color: var(--text-primary);
      padding: 10px 14px;
      font-size: 0.95rem;
      font-weight: 500;
      font-family: inherit;
      outline: none;
    }
    .search-input::placeholder {
      color: var(--text-secondary);
      opacity: 0.7;
    }

    .search-btn, .random-btn {
      padding: 0;
      width: 36px;
      height: 36px;
      flex-shrink: 0;
      font-size: 1.2rem;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      border-radius: 8px;
      cursor: pointer;
    }
    .search-btn:hover, .random-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-primary);
    }

    .autocomplete-results {
        display: none;
        position: absolute;
        top: 105%;
        left: 0;
        right: 0;
        background: var(--surface-2);
        backdrop-filter: blur(12px);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        max-height: 220px;
        overflow-y: auto;
        z-index: 999;
        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }

    .autocomplete-item {
        padding: 12px 16px;
        cursor: pointer;
        color: var(--text-primary);
        transition: all 0.2s ease;
        font-size: 0.9rem;
        border-bottom: 1px solid var(--border-color);
    }
    .autocomplete-item:last-child {
        border-bottom: none;
    }

    .autocomplete-item small {
        opacity: 0.7;
        display: block;
        font-size: 0.8rem;
    }

    .autocomplete-item:hover, .autocomplete-item.active {
        background: var(--accent);
        color: var(--accent-dark);
    }

    /* NEW: Mobile Search Trigger & Overlay */
    #mobile-search-trigger {
        display: none;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 101;
        background: var(--surface-1);
        backdrop-filter: blur(12px);
        border: 1px solid var(--border-color);
        border-radius: 50%;
        width: 44px;
        height: 44px;
        font-size: 1.4rem;
        color: var(--text-primary);
        cursor: pointer;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
    }
    #mobile-search-trigger:hover {
        border-color: var(--accent);
        color: var(--accent);
    }

    #search-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(15, 20, 25, 0.8);
        backdrop-filter: blur(10px);
        z-index: 200;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding: 15vh 20px 20px;
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    #search-overlay.visible {
        display: flex;
        opacity: 1;
    }
    #search-overlay .search-box {
        width: 100%;
        max-width: 500px;
        border-color: var(--border-color);
    }
    #close-search-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        font-size: 2.5rem;
        line-height: 1;
        font-weight: 200;
        color: var(--text-secondary);
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 10px;
    }
    #close-search-btn:hover {
        color: var(--text-primary);
    }

    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-primary);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 180px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    /* Buttons */
    button {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-secondary);
      cursor: pointer;
      padding: 12px 20px;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      background: var(--accent);
      color: var(--accent-dark);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      border-color: var(--accent);
    }

    button:active {
      transform: translateY(0);
    }

    #toggle-btn {
      width: 44px;
      height: 44px;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      padding: 0;
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 44px;
      height: 180px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 0.9rem;
      border-radius: 10px;
    }

    /* Copy confirmation */
    #copy-confirmation {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translate(-50%, 40px);
      background: var(--accent);
      color: var(--accent-dark);
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    /* 3D graph container */
    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: transparent;
    }

    #graph-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(15, 20, 25, 0.6) 100%);
      z-index: 1;
      pointer-events: none;
    }
    
    /* Legend */
    #legend {
      position: fixed;
      top: 90px;
      right: 20px;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 16px 20px;
      z-index: 99;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      transition: all 0.3s ease;
      max-width: 220px;
      display: none;
    }

    #legend.visible {
      display: block;
    }

    #legend-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin: 0 0 12px 0;
      color: var(--text-primary);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      font-size: 0.9rem;
      padding: 4px;
      border-radius: 4px;
      transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.2s ease;
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255, 0.2);
      flex-shrink: 0;
    }

    .legend-label {
      color: var(--text-secondary);
      font-weight: 500;
      transition: color 0.2s ease;
    }
    .legend-item:hover .legend-label {
        color: var(--text-primary);
    }

    /* Breathing toggle button */
    #breathing-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--surface-1);
      backdrop-filter: blur(12px);
      border: 1px solid var(--border-color);
      border-radius: 50%;
      width: 56px;
      height: 56px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.37);
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1.5rem;
      color: var(--accent);
    }

    #breathing-toggle:hover {
      transform: scale(1.05);
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.2);
    }

    #breathing-toggle.active {
      background: var(--accent);
      color: var(--accent-dark);
      box-shadow: 0 0 20px rgba(125, 184, 168, 0.4);
    }

    /* Responsive improvements */
    @media (max-width: 1200px) {
      .desktop-search {
        display: none; /* Hide desktop search */
      }
      #mobile-search-trigger {
        display: flex; /* Show mobile search trigger */
      }
      #legend {
        display: none !important;
      }
    }
    
    @media (max-width: 768px) {
      #menu {
        width: calc(100vw - 32px);
        max-width: calc(100vw - 32px);
        padding: 16px 20px;
        top: 16px;
        left: 16px;
        max-height: calc(100vh - 32px);
      }

      #menu.closed {
        padding: 12px 10px;
        width: auto;
      }
      
      #mobile-search-trigger {
        top: 16px;
        right: 16px;
      }

      #cycle-section {
        display: none;
      }

      #breathing-toggle {
        bottom: 16px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 1.3rem;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* Focus states for keyboard navigation */
    button:focus,
    nav ul li a:focus {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <!-- REMOVED: Mobile-specific search bar from inside the menu -->
    <div id="community-section">
        <h3 id="community-title">Community View</h3>
        <select id="community-select">
          <option value="none">Default View</option>
          <option value="author">By Author</option>
          <option value="phase">By Project Phase</option>
        </select>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn" aria-label="Toggle menu">×</button>
      <button id="copy-btn">📋 Copy network<br>adjacency matrix</button>
    </div>
  </nav>

  <!-- NEW: Timeline Controls -->
  <div id="cycle-section">
      <h3>Timeline</h3>
      <div id="cycle-slider-container">
          <label id="cycle-slider-label" for="cycle-slider">
              <span>View up to cycle:</span>
              <span id="cycle-slider-value">All</span>
          </label>
          <input type="range" id="cycle-slider" min="0" max="1" value="1" step="1">
      </div>
      <div id="cycle-toggles">
          <!-- Checkboxes will be dynamically inserted here -->
      </div>
  </div>

  <!-- This search bar is now only for desktop -->
  <div class="desktop-search">
    <div class="search-box">
      <input type="text" class="search-input" placeholder="Search piece or artist...">
      <button class="search-btn" aria-label="Search">🔍</button>
      <button class="random-btn" aria-label="Jump to random node">🎲</button>
      <div class="autocomplete-results"></div>
    </div>
  </div>
  
  <!-- NEW: Mobile Search Trigger Button -->
  <button id="mobile-search-trigger" aria-label="Open search">🔍</button>

  <!-- NEW: Search Overlay for mobile -->
  <div id="search-overlay">
      <button id="close-search-btn" aria-label="Close search">&times;</button>
      <div class="search-box">
        <input type="text" class="search-input" placeholder="Search piece or artist...">
        <button class="search-btn" aria-label="Search">🔍</button>
        <button class="random-btn" aria-label="Jump to random node">🎲</button>
        <div class="autocomplete-results"></div>
      </div>
  </div>


  <div id="copy-confirmation" role="alert" aria-live="polite">Copied!</div>
  <div id="legend">
    <h4 id="legend-title">Communities</h4>
    <div id="legend-items"></div>
  </div>
  <div id="breathing-toggle" title="Toggle organism breathing" aria-label="Toggle breathing animation">
    💨
  </div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // State
    let Graph;
    // Master lists for all data
    let allNodes = [];
    let allLinks = [];
    // These now represent the VISIBLE data
    let nodes = [];
    let links = [];
    let adjacencyMatrix = [];
    let communities = {};
    let colors = {};
    let uniqueArtists = [];
    let currentCommunityView = 'none';
    let isBreathing = false; // Off by default
    let isEngineSettled = false;
    let phase = 0;
    let hoverNode = null;
    let activeLegendCategory = null;
    let autocompleteIndex = -1;
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    const nodeSprites = new Map();
    const proximityThreshold = 100; // Distance to trigger high-res load
    const thumbnailTextures = new Map();
    const highresTextures = new Map();
    
    const artistNameMap = {
        "Arango Franco Sara": "Sara Arango-Franco",
        "Bulla Lina": "Lina Bulla",
        "Camacho Cabrera Gabriel": "Gabriel Camacho Cabrera",
        "elly": "Ellynne Dec",
        "Emerson Paquette": "Emerson Paquette",
        "Louison Halgand": "Louison Halgand",
        "Nadine AbdElRazek": "Nadine AbdElRazek",
        "Phileas Dazeley Gaist": "Phileas Dazeley-Gaist",
        "Sonal Raghuvanshi": "Sonal Raghuvanshi",
        "Thompson Kyle": "Kyle Thompson"
    };

    // Helper to generate a color palette
    function generateColorPalette(keys) {
        const palette = ["#FF6B6B", "#4ECDC4", "#45B7D1", "#FFA07A", "#98D8C8", "#F7DC6F", "#BB8FCE", "#F1948A"];
        const colorMap = {};
        keys.forEach((key, index) => {
            colorMap[key] = palette[index % palette.length];
        });
        return colorMap;
    }

    // Fetches and processes graph data from JSON files
    async function loadAndProcessGraphData() {
        try {
            const [verticesRes, edgesRes] = await Promise.all([
                fetch('./graph/vertices.json'),
                fetch('./graph/edges.json')
            ]);

            if (!verticesRes.ok || !edgesRes.ok) {
                throw new Error(`Failed to load graph data files. Status: Vertices ${verticesRes.status}, Edges ${edgesRes.status}`);
            }

            const verticesMap = await verticesRes.json();
            const edgesList = await edgesRes.json();
            
            const tempCommunities = { author: {}, phase: {} };
            const uniqueAuthorsSet = new Set();
            const uniquePhases = new Set();
            const uniqueCycles = new Set();

            // Build graph data
            const localNodes = Object.entries(verticesMap).map(([id, filename]) => {
                const parts = filename.split('-');
              const cycle = parseInt(parts[0], 10);
                const phase = `Phase ${parts[0]}`;
                const authorFromFile = (parts[1] || 'Unknown').replace(/_/g, ' ');
                const author = artistNameMap[authorFromFile] || authorFromFile;
                
              if (!isNaN(cycle)) {
                uniqueCycles.add(cycle);
              }

                uniqueAuthorsSet.add(author);
                uniquePhases.add(phase);

                if (!tempCommunities.author[author]) tempCommunities.author[author] = [];
                tempCommunities.author[author].push(parseInt(id, 10));

                if (!tempCommunities.phase[phase]) tempCommunities.phase[phase] = [];
                tempCommunities.phase[phase].push(parseInt(id, 10));

                return {
                    id: parseInt(id, 10),
                    cycle,
                    img: `${filename}.jpeg`,
                    name: filename.replace(/_/g, ' '),
                    author,
                    phase,
                    neighbors: [],
                    links: [],
                    textureState: 'thumbnail',
                    currentScale: 22,
                    targetScale: 22,
                    currentOpacity: 0.9,
                    targetOpacity: 0.9
                };
            });
            
            uniqueArtists = Array.from(uniqueAuthorsSet).sort();
            const sortedPhases = Array.from(uniquePhases).sort();

            const tempColors = {
                author: generateColorPalette(uniqueArtists),
                phase: generateColorPalette(sortedPhases)
            };


            const localLinks = edgesList.map(([source, target]) => ({
                source: parseInt(source, 10),
                target: parseInt(target, 10),
                currentOpacity: 0.8,
                targetOpacity: 0.8
            }));
            
            const edgeSet = new Set(edgesList.map(([s, t]) => `${s},${t}`));

            localLinks.forEach(link => {
                const revLinkExists = edgeSet.has(`${link.target},${link.source}`);
                if (revLinkExists) {
                    link.curvature = link.source < link.target ? 0.4 : -0.4;
                    link.rotation = link.source < link.target ? 0 : Math.PI / 2;
                } else {
                    link.curvature = 0;
                    link.rotation = 0;
                }
            });

            const nodeMap = new Map(localNodes.map(node => [node.id, node]));
            localLinks.forEach(link => {
                const a = nodeMap.get(link.source);
                const b = nodeMap.get(link.target);
                if (a && b) {
                    a.neighbors.push(b);
                    b.neighbors.push(a);
                    a.links.push(link);
                    b.links.push(link);
                }
            });

            const nodeIds = localNodes.map(n => n.id);
            const maxId = Math.max(0, ...nodeIds);
            const localAdjacencyMatrix = Array(maxId + 1).fill(0).map(() => Array(maxId + 1).fill(0));
            edgesList.forEach(([source, target]) => {
                if (source <= maxId && target <= maxId) {
                    localAdjacencyMatrix[source][target] = 1;
                }
            });
            
            const sortedCycles = Array.from(uniqueCycles).sort((a,b) => a - b);
            
            return { 
                nodes: localNodes, 
                links: localLinks, 
                adjacencyMatrix: localAdjacencyMatrix,
                communities: tempCommunities,
                colors: tempColors,
                uniqueCycles: sortedCycles,
                maxCycle: Math.max(0, ...sortedCycles)
            };
        } catch (error) {
            console.error("Error loading graph:", error);
            document.getElementById('3d-graph').innerHTML = `<div style="color: #ff6b6b; padding: 40px; text-align: center; font-size: 1.2rem;"><h2>Failed to Load Organism</h2><p>${error.message}</p><p>Please check the console for more details.</p></div>`;
            return null;
        }
    }

    // Function to filter graph data based on timeline controls
    function updateGraphData() {
        const slider = document.getElementById('cycle-slider');
        const maxVisibleCycle = parseInt(slider.value, 10);
        
        const toggles = document.querySelectorAll('#cycle-toggles input:checked');
        const visibleCycles = new Set(Array.from(toggles).map(cb => parseInt(cb.value, 10)));

        // Determine which nodes should be visible
        const visibleNodeIds = new Set();
        allNodes.forEach(node => {
            if (node.cycle <= maxVisibleCycle && visibleCycles.has(node.cycle)) {
                visibleNodeIds.add(node.id);
            }
        });

        // Update the globally scoped 'nodes' and 'links' for other functions that rely on them
        nodes = allNodes.filter(node => visibleNodeIds.has(node.id));
        links = allLinks.filter(link => {
            const sourceId = link.source.id ?? link.source;
            const targetId = link.target.id ?? link.target;
            return visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
        });

        // Update the graph's visibility without changing its underlying data
        Graph.nodeVisibility(node => visibleNodeIds.has(node.id));
        Graph.linkVisibility(link => {
            const sourceId = link.source.id ?? link.source;
            const targetId = link.target.id ?? link.target;
            return visibleNodeIds.has(sourceId) && visibleNodeIds.has(targetId);
        });
    }


    // Function to setup the timeline UI
    function setupTimelineControls(uniqueCycles, maxCycle) {
        const slider = document.getElementById('cycle-slider');
        const sliderValueLabel = document.getElementById('cycle-slider-value');
        const togglesContainer = document.getElementById('cycle-toggles');
        
        if (uniqueCycles.length === 0) {
            document.getElementById('cycle-section').style.display = 'none';
            return;
        };
        
        const min = Math.min(...uniqueCycles);
        
        slider.min = min;
        slider.max = maxCycle;
        slider.value = maxCycle;
        sliderValueLabel.textContent = `All (${maxCycle})`;

        slider.addEventListener('input', () => {
            sliderValueLabel.textContent = slider.value == maxCycle ? `All (${maxCycle})` : slider.value;
            updateGraphData();
        });

        togglesContainer.innerHTML = '';
        uniqueCycles.forEach(cycle => {
            const label = document.createElement('label');
            label.className = 'cycle-toggle-label';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = cycle;
            checkbox.checked = true;
            checkbox.addEventListener('change', updateGraphData);
            
            const text = document.createTextNode(` ${cycle}`);
            
            label.appendChild(checkbox);
            label.appendChild(text);
            togglesContainer.appendChild(label);
        });
    }

    // Helper functions
    function getNodeColor(node) {
      if (highlightNodes.has(node)) {
        // When highlighted, show the image without any color tint.
        return '#ffffff';
      }
      
      if (currentCommunityView === 'none') return '#ffffff';
      
      const communityData = communities[currentCommunityView];
      const colorData = colors[currentCommunityView];
      
      if (communityData && colorData) {
        const key = node[currentCommunityView];
        if (key && colorData[key]) {
            return colorData[key];
        }
      }
      
      return '#ffffff';
    }

    function getLinkColor(link) {
        if (highlightLinks.has(link)) return '#7ED377';
        // Ensure source/target are objects before accessing id
        if (currentCommunityView === 'none' || typeof link.source !== 'object' || typeof link.target !== 'object' || !link.source.id || !link.target.id) return '#7db8a8';

        const communityData = communities[currentCommunityView];
        const colorData = colors[currentCommunityView];
        
        const sourceNode = nodes.find(n => n.id === link.source.id);
        const targetNode = nodes.find(n => n.id === link.target.id);
        
        if (sourceNode && targetNode && communityData && colorData) {
            const sourceCommunity = sourceNode[currentCommunityView];
            const targetCommunity = targetNode[currentCommunityView];
            
            if (sourceCommunity && targetCommunity) {
                return sourceCommunity === targetCommunity ? colorData[sourceCommunity] : '#FFA726'; // Orange for inter-community links
            }
        }
        
       return '#7db8a8';
    }

    // Dynamic Texture Loading System
    function manageDynamicTextures() {
        if (!Graph || !Graph.camera()) return;

        const cameraPosition = Graph.camera().position;

        nodes.forEach(node => {
            if (!node.__threeObj) return;

            const nodePosition = node.__threeObj.position;
            const distance = cameraPosition.distanceTo(nodePosition);

            if (distance < proximityThreshold) {
                if (node.textureState === 'thumbnail') {
                    node.textureState = 'loading_highres';

                    const highResUrl = `./art-imgs/${node.img}`;
                    new THREE.TextureLoader().load(
                        highResUrl,
                        (highResTexture) => {
                            highResTexture.colorSpace = THREE.SRGBColorSpace;
                            if (node.__threeObj) {
                                node.__threeObj.material.map = highResTexture;
                                highresTextures.set(node.id, highResTexture);
                                node.textureState = 'highres';
                            } else {
                              highResTexture.dispose();
                            }
                        },
                        undefined,
                        (error) => {
                            console.error(`Failed to load high-res image for node ${node.id}: ${highResUrl}`, error);
                            node.textureState = 'thumbnail';
                        }
                    );
                }
            } else {
                if (node.textureState === 'highres') {
                    const thumbnailTexture = thumbnailTextures.get(node.id);
                    if (thumbnailTexture && node.__threeObj) {
                        node.__threeObj.material.map = thumbnailTexture;
                    }

                    const highResTexture = highresTextures.get(node.id);
                    if (highResTexture) {
                        highResTexture.dispose();
                        highresTextures.delete(node.id);
                    }
                    node.textureState = 'thumbnail';
                }
            }
        });
    }

    function updateGraphVisuals() {
        const isCommunityHighlightActive = activeLegendCategory !== null;
        const easing = 0.1;

        // 1. Determine TARGETS for nodes
        nodes.forEach(node => {
            const isHighlighted = highlightNodes.has(node);
            if (isCommunityHighlightActive) {
                if (isHighlighted) {
                    node.targetScale = 30;
                    node.targetOpacity = 1.0;
                } else {
                    node.targetScale = 18;
                    node.targetOpacity = 0.3; 
                }
            } else if (hoverNode) {
                node.targetScale = 22;
                node.targetOpacity = isHighlighted ? 1.0 : 0.35;
            } else {
                node.targetScale = 22;
                node.targetOpacity = 0.9;
            }
        });

        // 2. Determine TARGETS for links
        links.forEach(link => {
            if (isCommunityHighlightActive) {
                link.targetOpacity = highlightLinks.has(link) ? 0.9 : 0.15;
            } else if (hoverNode) {
                link.targetOpacity = highlightLinks.has(link) ? 0.9 : 0.15;
            } else {
                link.targetOpacity = 0.8;
            }
        });

        // 3. INTERPOLATE and APPLY for nodes
        nodeSprites.forEach((sprite, nodeId) => {
            const node = nodes.find(n => n.id === nodeId);
            if (!sprite || !node || !sprite.material) return;

            // Interpolate
            node.currentScale += (node.targetScale - node.currentScale) * easing;
            node.currentOpacity += (node.targetOpacity - node.currentOpacity) * easing;

            let finalScale = node.currentScale;
            if (isBreathing && isEngineSettled) {
                const scalePhase = phase + (node.id * 0.5);
                finalScale = node.currentScale * (1 + 0.25 * Math.sin(scalePhase));
            }
            
            sprite.scale.set(finalScale, finalScale, 1);
            sprite.material.color.set(getNodeColor(node));
            sprite.material.opacity = node.currentOpacity;
        });

        // 4. INTERPOLATE for links
        Graph.graphData().links.forEach(link => {
            link.currentOpacity += (link.targetOpacity - link.currentOpacity) * easing;
        });

        // 5. Update non-interpolated visuals
        Graph.linkWidth(link => highlightLinks.has(link) ? 3 : 1.5)
             .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0);
    }
    
    function startRenderLoop() {
        function renderLoop() {
            if (isBreathing) {
                phase += 0.02;
            }
            manageDynamicTextures();
            updateGraphVisuals();
            requestAnimationFrame(renderLoop);
        }
        renderLoop();
    }


    // Initialize graph
    function initGraph() {
      Graph = ForceGraph3D()(document.getElementById('3d-graph'))
        .graphData({ nodes: allNodes, links: allLinks })
        .backgroundColor('rgba(0,0,0,0)')
        .nodeThreeObject(node => {
            const currentNode = { ...node };
            const material = new THREE.SpriteMaterial({
                transparent: true,
                opacity: 0.9,
                color: getNodeColor(currentNode)
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(22, 22, 1);
            nodeSprites.set(currentNode.id, sprite);

            const loader = new THREE.TextureLoader();
            loader.load(
                `./art-thumbnails/${currentNode.img}`,
                (texture) => {
                    texture.colorSpace = THREE.SRGBColorSpace;
                    thumbnailTextures.set(currentNode.id, texture);
                    const spriteToUpdate = nodeSprites.get(currentNode.id);
                    if (spriteToUpdate) {
                        spriteToUpdate.material.map = texture;
                        spriteToUpdate.material.color.set(getNodeColor(currentNode));
                        spriteToUpdate.material.needsUpdate = true;
                    }
                },
                undefined,
                (error) => {
                    console.error(`Image failed for node ${currentNode.id} (${currentNode.img}):`, error);
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = 128;
                    canvas.height = 128;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#2a3b4d';
                    ctx.fillRect(0, 0, 128, 128);
                    ctx.fillStyle = '#c2d4d0';
                    ctx.font = '16px "DM Sans", system-ui, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Image', 64, 56);
                    ctx.fillText('Not Found', 64, 72);
                    
                    const fallbackTexture = new THREE.CanvasTexture(canvas);
                    thumbnailTextures.set(currentNode.id, fallbackTexture);

                    const spriteToUpdate = nodeSprites.get(currentNode.id);
                    if (spriteToUpdate) {
                        spriteToUpdate.material.map = fallbackTexture;
                        spriteToUpdate.material.needsUpdate = true;
                    }
                }
            );
            
            return sprite;
        })
        .nodeColor(() => null)
        .linkWidth(1.5)
        .linkDirectionalArrowLength(8)
        .linkDirectionalArrowRelPos(0.85)
        .linkColor(getLinkColor)
        .linkOpacity(link => link.currentOpacity) // Use interpolated value
        .linkCurvature(link => link.curvature || 0)
        .linkCurveRotation(link => link.rotation || 0)
        .nodeLabel(node => {
          const fileName = node.img.split('/').pop().split('.')[0];
          let communityInfo = '';
          if (currentCommunityView !== 'none') {
              communityInfo = `<br><small>${node[currentCommunityView]}</small>`;
          }
          return `<div style="background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 6px; color: var(--text-primary); font-size: 12px; font-weight: 500;">${fileName}${communityInfo}</div>`;
        })
        .onNodeHover(node => {
          if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

          activeLegendCategory = null;
          updateLegendStyles();

          highlightNodes.clear();
          highlightLinks.clear();

          if (node) {
            highlightNodes.add(node);
            node.neighbors.forEach(n => highlightNodes.add(n));
            node.links.forEach(l => highlightLinks.add(l));
          }

          hoverNode = node || null;
        })
        .onLinkHover(link => {
          highlightNodes.clear();
          highlightLinks.clear();

          activeLegendCategory = null;
          updateLegendStyles();

          if (link) {
            highlightLinks.add(link);
            highlightNodes.add(link.source);
            highlightNodes.add(link.target);
          }
        })
        .onNodeClick(node => {
          if (!node) return;
          const distance = 60;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
          const newPos = {
            x: node.x * distRatio,
            y: node.y * distRatio,
            z: node.z * distRatio
          };
          Graph.cameraPosition(newPos, node, 2000);
        })
        .onEngineStop(() => {
            console.log("Force engine stopped. Capturing natural positions.");
            allNodes.forEach(node => {
                node.naturalX = node.x;
                node.naturalY = node.y;
                node.naturalZ = node.z;
            });
            isEngineSettled = true;
        });

      Graph.controls().enableDamping = true;
      Graph.controls().dampingFactor = 0.05;
    }
    
    // UI Event handlers
    function updateLegendStyles() {
        const legendItems = document.querySelectorAll('.legend-item');
        legendItems.forEach(item => {
            const itemName = item.dataset.name;
            if (activeLegendCategory === null) {
                item.style.opacity = '1';
                item.style.transform = 'translateX(0)';
                item.style.background = 'transparent';

            } else if (activeLegendCategory === itemName) {
                item.style.opacity = '1';
                item.style.transform = 'translateX(0)';
                item.style.background = 'rgba(255, 255, 255, 0.1)';
            } else {
                item.style.opacity = '0.5';
                item.style.transform = 'translateX(-2px)';
                item.style.background = 'transparent';
            }
        });
    }

    function updateCommunityView() {
      // This function now only needs to update the legend, 
      // as the render loop handles node color changes.
      const legend = document.getElementById('legend');
      const legendItems = document.getElementById('legend-items');
      
      if (currentCommunityView === 'none') {
        legend.classList.remove('visible');
        return;
      }
      
      legend.classList.add('visible');
      legendItems.innerHTML = '';
      
      const colorData = colors[currentCommunityView];
      
      if (colorData) {
        Object.entries(colorData).sort((a, b) => a[0].localeCompare(b[0])).forEach(([name, color]) => {
          const item = document.createElement('div');
          item.className = 'legend-item';
          item.dataset.name = name;
          item.style.cursor = 'pointer';
          
          const colorBox = document.createElement('div');
          colorBox.className = 'legend-color';
          colorBox.style.backgroundColor = color;
          
          const label = document.createElement('span');
          label.className = 'legend-label';
          label.textContent = name;
          
          item.appendChild(colorBox);
          item.appendChild(label);
          legendItems.appendChild(item);

          item.addEventListener('click', () => {
              if (activeLegendCategory === name) {
                  activeLegendCategory = null;
                  highlightNodes.clear();
                  highlightLinks.clear();
              } else {
                  activeLegendCategory = name;
                  highlightNodes.clear();
                  highlightLinks.clear();

                  const nodeIdsToHighlight = communities[currentCommunityView][name];
                  if (nodeIdsToHighlight) {
                      const nodesInCommunity = new Set();
                      nodeIdsToHighlight.forEach(id => {
                          const nodeToHighlight = nodes.find(n => n.id === id);
                          if (nodeToHighlight) {
                              highlightNodes.add(nodeToHighlight);
                              nodesInCommunity.add(nodeToHighlight);
                          }
                      });

                      links.forEach(link => {
                          if (nodesInCommunity.has(link.source) && nodesInCommunity.has(link.target)) {
                              highlightLinks.add(link);
                          }
                      });
                  }
              }
              updateLegendStyles();
          });
        });
      }
    }

    function closeAllAutocompletes() {
        document.querySelectorAll('.autocomplete-results').forEach(el => el.style.display = 'none');
    }

    // Event listeners
    document.getElementById('toggle-btn').addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const isOpen = !menu.classList.contains('closed');
      menu.classList.toggle('closed', isOpen);
      document.getElementById('toggle-btn').textContent = isOpen ? '☰' : '×';
    });

    document.getElementById('community-select').addEventListener('change', (e) => {
        currentCommunityView = e.target.value;
        activeLegendCategory = null;
        updateCommunityView();
    });

    document.getElementById('breathing-toggle').addEventListener('click', () => {
      const toggle = document.getElementById('breathing-toggle');
      isBreathing = !isBreathing;
      toggle.classList.toggle('active', isBreathing);
    });

    document.getElementById('copy-btn').addEventListener('click', async () => {
      const text = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
      try {
        await navigator.clipboard.writeText(text);
      } catch (err) {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
      }
      const confirm = document.getElementById('copy-confirmation');
      confirm.classList.add('visible');
      setTimeout(() => confirm.classList.remove('visible'), 2000);
    });

    // NEW: Listeners for mobile search overlay
    const searchOverlay = document.getElementById('search-overlay');
    const mobileSearchTrigger = document.getElementById('mobile-search-trigger');
    const closeSearchBtn = document.getElementById('close-search-btn');

    mobileSearchTrigger.addEventListener('click', () => {
        searchOverlay.classList.add('visible');
        searchOverlay.querySelector('.search-input').focus();
    });

    closeSearchBtn.addEventListener('click', () => {
        searchOverlay.classList.remove('visible');
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        const menu = document.getElementById('menu');
        if (!menu.classList.contains('closed')) {
          document.getElementById('toggle-btn').click();
        }
        if (searchOverlay.classList.contains('visible')) {
            searchOverlay.classList.remove('visible');
        }
        closeAllAutocompletes();
      }
    });

    function focusOnNode(node) {
        const distance = 80;
        const distRatio = 1 + distance / Math.hypot(node.x || 0, node.y || 0, node.z || 0);
        const newPos = {
          x: (node.x || 0) * distRatio,
          y: (node.y || 0) * distRatio,
          z: (node.z || 0) * distRatio
        };
        Graph.cameraPosition(newPos, node, 1000);
        
        highlightNodes.clear();
        highlightLinks.clear();
        highlightNodes.add(node);
        node.neighbors.forEach(n => highlightNodes.add(n));
        node.links.forEach(l => highlightLinks.add(l));
        hoverNode = node;
    }

    function panToNode(node) {
        const distance = 80;
        const distRatio = 1 + distance / Math.hypot(node.x || 0, node.y || 0, node.z || 0);
        const newPos = {
          x: (node.x || 0) * distRatio,
          y: (node.y || 0) * distRatio,
          z: (node.z || 0) * distRatio
        };
        Graph.cameraPosition(newPos, node, 1000);

        // Clear any existing highlights when jumping to a random node
        highlightNodes.clear();
        highlightLinks.clear();
        hoverNode = null;
    }

    document.querySelectorAll('.search-box').forEach(searchBox => {
        const searchInput = searchBox.querySelector('.search-input');
        const autocompleteResults = searchBox.querySelector('.autocomplete-results');

        const performSearch = () => {
            const searchValue = searchInput.value.trim();
            const searchValueLower = searchValue.toLowerCase();

            const artistMatch = uniqueArtists.find(a => a.toLowerCase() === searchValueLower);
            if(artistMatch){
                highlightNodes.clear();
                highlightLinks.clear();
                const nodesByArtist = nodes.filter(n => n.author === artistMatch);
                const artistNodeSet = new Set(nodesByArtist);
                artistNodeSet.forEach(node => highlightNodes.add(node));
                links.forEach(link => {
                    if(artistNodeSet.has(link.source) && artistNodeSet.has(link.target)){
                        highlightLinks.add(link);
                    }
                });
                closeAllAutocompletes();
                searchOverlay.classList.remove('visible'); // Close overlay on success
                return;
            }

            const nodeByName = nodes.find(n => n.name.toLowerCase() === searchValueLower);
            if(nodeByName){
                focusOnNode(nodeByName);
                closeAllAutocompletes();
                searchOverlay.classList.remove('visible'); // Close overlay on success
                return;
            }

            const nodeById = nodes.find(n => n.id.toString() === searchValue);
            if(nodeById){
                focusOnNode(nodeById);
                closeAllAutocompletes();
                searchOverlay.classList.remove('visible'); // Close overlay on success
                return;
            }
            
            searchInput.value = '';
            searchInput.placeholder = 'No results found!';
            setTimeout(() => { searchInput.placeholder = 'Search piece or artist...'; }, 2000);
            closeAllAutocompletes();
        }

        searchInput.addEventListener('input', () => {
            const value = searchInput.value.toLowerCase();
            autocompleteResults.innerHTML = '';
            if (value.length === 0) {
                closeAllAutocompletes();
                return;
            }

            const matchingNodes = nodes
                .filter(node => node.name.toLowerCase().includes(value))
                .slice(0, 10);

            if (matchingNodes.length > 0) {
                matchingNodes.forEach(node => {
                    const item = document.createElement('div');
                    item.className = 'autocomplete-item';
                    item.innerHTML = `<b>${node.name}</b><small>by ${node.author}</small>`;
                    item.addEventListener('click', () => {
                        searchInput.value = node.name;
                        performSearch();
                    });
                    autocompleteResults.appendChild(item);
                });
                autocompleteResults.style.display = 'block';
            } else {
                closeAllAutocompletes();
            }
            autocompleteIndex = -1;
        });

        searchInput.addEventListener('keydown', (e) => {
            const items = autocompleteResults.getElementsByClassName('autocomplete-item');
            if (e.key === 'Enter') {
                e.preventDefault();
                if (autocompleteIndex > -1) {
                    items[autocompleteIndex].click();
                } else {
                    performSearch();
                }
            } else if (items.length > 0) {
                if (e.key === 'ArrowDown') {
                    autocompleteIndex = (autocompleteIndex + 1) % items.length;
                    updateAutocompleteActive(items);
                } else if (e.key === 'ArrowUp') {
                    autocompleteIndex = (autocompleteIndex - 1 + items.length) % items.length;
                    updateAutocompleteActive(items);
                }
            }
        });
        
        const updateAutocompleteActive = (items) => {
            Array.from(items).forEach((item, index) => {
                item.classList.toggle('active', index === autocompleteIndex);
            });
        }

        searchBox.querySelector('.search-btn').addEventListener('click', performSearch);
    });

    document.querySelectorAll('.random-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            if (nodes.length > 0) {
                const randomNode = nodes[Math.floor(Math.random() * nodes.length)];
                if (randomNode) panToNode(randomNode);
                document.querySelectorAll('.search-input').forEach(input => input.value = '');
                searchOverlay.classList.remove('visible'); // Close overlay
            }
        });
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.search-box')) {
            closeAllAutocompletes();
        }
    });

    // Initialize App
    async function main() {
        const menu = document.getElementById('menu');
        const toggleBtn = document.getElementById('toggle-btn');
        
        // Default menu to closed on smaller windows on page load
        if (window.innerWidth <= 1200) {
          menu.classList.add('closed');
          toggleBtn.textContent = '☰';
        } else {
          toggleBtn.textContent = '×';
        }
        
        const graphData = await loadAndProcessGraphData();
        if (graphData) {
            // Set the master lists
            allNodes = graphData.nodes;
            allLinks = graphData.links;
            
            // Initially, the visible data is all the data
            nodes = [...allNodes];
            links = [...allLinks];

            adjacencyMatrix = graphData.adjacencyMatrix;
            communities = graphData.communities;
            colors = graphData.colors;

            initGraph();
            setupTimelineControls(graphData.uniqueCycles, graphData.maxCycle);
            startRenderLoop();
        }
    }

    window.addEventListener('load', main);
  </script>
</body>
</html>