<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    body {
      margin: 0;
      font-family: 'DM Sans', system-ui, sans-serif;
      background: #101011;
      color: #a3d9ca;
      overflow: hidden;
    }

    #menu {
      position: fixed;
      top: 16px;
      left: 16px;
      background: rgba(20, 30, 40, 0.9);
      border-radius: 12px;
      padding: 16px 24px;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
      box-shadow: inset 0 0 12px rgba(0, 238, 170, 0.1);
      transition: width 0.3s ease, padding 0.3s ease;
    }

    #menu.closed {
      width: auto;
      padding: 16px 12px;
      flex-direction: row;
      align-items: center;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box {
      display: none;
    }

    #title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: #a3d9ca;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: #00eeaa;
    }

    #subtitle {
      font-size: 1rem;
      opacity: 0.8;
      color: #a3d9ca;
    }

    #nav-box {
      background: rgba(0, 238, 170, 0.1);
      border: 1px solid rgba(0, 238, 170, 0.2);
      border-radius: 8px;
      padding: 12px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    nav ul li a {
      color: #a3d9ca;
      text-decoration: none;
      font-weight: 600;
      font-size: 1.1rem;
      padding: 6px 12px;
      border-radius: 10px;
      transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    nav ul li a:hover {
      background-color: #00eeaa;
      color: #042822;
      box-shadow: 0 0 8px 2px #00eeaa88;
    }

    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.4rem;
      font-weight: 600;
      color: #a3d9ca;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 160px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    button {
      background: #184e68;
      border: none;
      border-radius: 12px;
      color: #a3d9ca;
      cursor: pointer;
      padding: 10px 18px;
      font-size: 1rem;
      transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover {
      background: #00eeaa;
      color: #042822;
      box-shadow: 0 0 8px 2px #00eeaa88;
    }

    #toggle-btn {
      width: 40px;
      height: 40px;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 40px;
      height: 170px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 1rem;
    }

    #copy-confirmation {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translate(-50%, 20px);
      background: #00eeaacc;
      color: #042822;
      padding: 10px 24px;
      border-radius: 14px;
      font-weight: 600;
      font-size: 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 1000;
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: #000003;
    }

    /* Radial fade overlay */
    #graph-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, #0f1520 100%);
      z-index: 1;
      pointer-events: none;
    }

    /* Responsive tweaks */
    @media (max-width: 768px) {
      #menu {
        width: 90vw;
        padding: 12px 16px;
      }

      #menu.closed {
        padding: 12px 10px;
      }

      #title {
        font-size: 1.2rem;
      }

      #subtitle {
        font-size: 0.9rem;
      }

      nav ul li a {
        font-size: 1rem;
      }

      button {
        font-size: 0.9rem;
        padding: 8px 14px;
      }

      #menu.closed #copy-btn {
        height: 120px;
        font-size: 0.8rem;
      }

      #title-vertical {
        max-height: 120px;
      }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn">Ã—</button>
      <button id="copy-btn">ðŸ“‹ Copy network adjacency matrix</button>
    </div>
  </nav>

  <div id="copy-confirmation">Copied!</div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // Generate 250 nodes with different types
    const nodeTypes = [
      'concept', 'artwork', 'artist', 'medium', 'technique', 
      'movement', 'theme', 'emotion', 'color', 'texture',
      'sound', 'vision', 'memory', 'dream', 'reality'
    ];

    const nodeColors = {
      concept: '#FF6B6B',
      artwork: '#4ECDC4', 
      artist: '#45B7D1',
      medium: '#96CEB4',
      technique: '#FFEAA7',
      movement: '#DDA0DD',
      theme: '#98D8C8',
      emotion: '#F7DC6F',
      color: '#BB8FCE',
      texture: '#85C1E9',
      sound: '#F8C471',
      vision: '#82E0AA',
      memory: '#F1948A',
      dream: '#C39BD3',
      reality: '#7FB3D3'
    };

    // Generate nodes
    const nodes = Array.from({length: 250}, (_, i) => {
      const type = nodeTypes[i % nodeTypes.length];
      return {
        id: i,
        name: `${type}_${Math.floor(i / nodeTypes.length) + 1}`,
        type: type,
        size: Math.random() * 3 + 1,
        intensity: Math.random()
      };
    });

    // Define the 250x250 adjacency matrix
    // This is a sample matrix - you can replace with your own data
    function createAdjacencyMatrix() {
      const size = 250;
      const matrix = Array(size).fill().map(() => Array(size).fill(0));
      
      // Example pattern: each node connects to a few specific others
      // You can replace this with your actual adjacency data
      for (let i = 0; i < size; i++) {
        // Connect to next 2-5 nodes (with wraparound)
        const connections = 2 + (i % 4); // 2-5 connections per node
        for (let j = 1; j <= connections; j++) {
          const target = (i + j) % size;
          matrix[i][target] = 1;
        }
        
        // Add some backward connections
        if (i > 0 && i % 3 === 0) {
          matrix[i][i - 1] = 1;
        }
        
        // Add some long-range connections based on mathematical patterns
        if (i % 7 === 0 && i + 50 < size) {
          matrix[i][i + 50] = 1;
        }
        if (i % 11 === 0 && i + 100 < size) {
          matrix[i][i + 100] = 1;
        }
      }
      
      return matrix;
    }

    const adjacencyMatrix = createAdjacencyMatrix();

    // Convert adjacency matrix to links
    const links = [];
    for (let i = 0; i < adjacencyMatrix.length; i++) {
      for (let j = 0; j < adjacencyMatrix[i].length; j++) {
        if (adjacencyMatrix[i][j]) {
          links.push({ source: i, target: j });
        }
      }
    }

    // Add curvature for bidirectional links
    const linkMap = new Map();
    links.forEach(link => {
      const key = `${link.source},${link.target}`;
      linkMap.set(key, link);
    });

    links.forEach(link => {
      const revKey = `${link.target},${link.source}`;
      if (link.source === link.target) {
        link.curvature = 0.5;
        link.rotation = 0;
      } else if (linkMap.has(revKey)) {
        if (link.source < link.target) {
          link.curvature = 0.3;
          link.rotation = 0;
        } else {
          link.curvature = -0.3;
          link.rotation = Math.PI / 4;
        }
      } else {
        link.curvature = 0;
        link.rotation = 0;
      }
    });

    // Build neighbor relationships
    nodes.forEach(node => {
      node.neighbors = [];
      node.links = [];
    });

    links.forEach(link => {
      const source = nodes[link.source];
      const target = nodes[link.target];
      source.neighbors.push(target);
      target.neighbors.push(source);
      source.links.push(link);
      target.links.push(link);
    });

    const gData = { nodes, links };

    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const baseArrowLength = 4;
    const hoverArrowLength = 8;

    const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
      .graphData(gData)
      .nodeThreeObject(node => {
        // Create different geometries based on node type
        let geometry;
        const type = node.type;
        
        if (type === 'concept' || type === 'theme') {
          geometry = new THREE.OctahedronGeometry(node.size);
        } else if (type === 'artwork' || type === 'vision') {
          geometry = new THREE.TetrahedronGeometry(node.size);
        } else if (type === 'artist' || type === 'emotion') {
          geometry = new THREE.SphereGeometry(node.size, 8, 6);
        } else if (type === 'medium' || type === 'technique') {
          geometry = new THREE.BoxGeometry(node.size, node.size, node.size);
        } else if (type === 'sound' || type === 'memory') {
          geometry = new THREE.ConeGeometry(node.size, node.size * 1.5, 6);
        } else {
          geometry = new THREE.IcosahedronGeometry(node.size);
        }
        
        const material = new THREE.MeshLambertMaterial({
          color: nodeColors[type] || '#6B8E23',
          transparent: true,
          opacity: 0.8
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add subtle animation
        const animSpeed = 0.001 + Math.random() * 0.002;
        mesh.userData = { animSpeed };
        
        return mesh;
      })
      .nodeColor(node => {
        const baseColor = nodeColors[node.type] || '#6B8E23';
        if (highlightNodes.has(node)) {
          return node === hoverNode ? '#FFD700' : '#FF8C00';
        }
        return baseColor;
      })
      .linkWidth(link => highlightLinks.has(link) ? 3 : 0.5)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0)
      .linkDirectionalParticleWidth(2)
      .linkDirectionalArrowLength(link => highlightLinks.has(link) ? hoverArrowLength : baseArrowLength)
      .linkDirectionalArrowRelPos(0.9)
      .linkDirectionalArrowColor(link => highlightLinks.has(link) ? '#FF4500' : '#00EEAA')
      .linkColor(link => highlightLinks.has(link) ? '#FF8C00' : '#00EEAA')
      .linkCurvature(link => link.curvature || 0)
      .linkCurveRotation(link => link.rotation || 0)
      .linkOpacity(0.6)
      .nodeLabel(node => `${node.name} (${node.type})`)
      .onNodeHover(node => {
        if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

        highlightNodes.clear();
        highlightLinks.clear();

        if (node) {
          highlightNodes.add(node);
          node.neighbors.forEach(n => highlightNodes.add(n));
          node.links.forEach(l => highlightLinks.add(l));
        }

        hoverNode = node || null;
        updateHighlight();
      })
      .onLinkHover(link => {
        highlightNodes.clear();
        highlightLinks.clear();

        if (link) {
          highlightLinks.add(link);
          highlightNodes.add(link.source);
          highlightNodes.add(link.target);
        }

        updateHighlight();
      })
      .onNodeClick(node => {
        if (!node) return;
        const distance = 50;
        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
        const newPos = {
          x: node.x * distRatio,
          y: node.y * distRatio,
          z: node.z * distRatio
        };
        Graph.cameraPosition(newPos, node, 2000);
      });

    // Add ambient lighting
    const scene = Graph.scene();
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);

    // Animate node rotations
    function animateNodes() {
      nodes.forEach(node => {
        const obj = Graph.getObjectByProperty('userData.nodeId', node.id);
        if (obj && obj.userData.animSpeed) {
          obj.rotation.x += obj.userData.animSpeed;
          obj.rotation.y += obj.userData.animSpeed * 0.7;
        }
      });
      requestAnimationFrame(animateNodes);
    }
    animateNodes();

    function updateHighlight() {
      Graph
        .nodeColor(Graph.nodeColor())
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles())
        .linkDirectionalArrowColor(Graph.linkDirectionalArrowColor())
        .linkDirectionalArrowLength(Graph.linkDirectionalArrowLength())
        .linkColor(Graph.linkColor());
    }

    // Menu toggle with rotation
    const toggleBtn = document.getElementById('toggle-btn');
    toggleBtn.addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const closed = menu.classList.toggle('closed');
      toggleBtn.textContent = closed ? 'â˜°' : 'Ã—';
      toggleBtn.style.transform = closed ? 'rotate(0deg)' : 'rotate(90deg)';
    });

    // Copy matrix function - copy full or partial matrix
    document.getElementById('copy-btn').addEventListener('click', async () => {
      try {
        let text;
        
        // For smaller matrices, copy the whole thing
        if (adjacencyMatrix.length <= 50) {
          text = '[\n' + adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
        } else {
          // For large matrices, offer to copy a sample or provide instructions
          const response = confirm('Matrix is large (250x250). Click OK to copy a 20x20 sample, or Cancel to copy the full matrix.');
          
          if (response) {
            // Copy 20x20 sample
            const sampleSize = 20;
            const sampleMatrix = adjacencyMatrix.slice(0, sampleSize).map(row => row.slice(0, sampleSize));
            text = '// Sample 20x20 section of ' + adjacencyMatrix.length + 'x' + adjacencyMatrix.length + ' matrix:\n[\n' + 
              sampleMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
          } else {
            // Copy full matrix
            text = '// Full ' + adjacencyMatrix.length + 'x' + adjacencyMatrix.length + ' adjacency matrix:\n[\n' + 
              adjacencyMatrix.map(row => '  [' + row.join(', ') + ']').join(',\n') + '\n]';
          }
        }
        
        await navigator.clipboard.writeText(text);
        const confirm = document.getElementById('copy-confirmation');
        confirm.classList.add('visible');
        setTimeout(() => confirm.classList.remove('visible'), 1500);
      } catch (err) {
        alert('Copy failed');
      }
    });
  </script>
</body>
</html>