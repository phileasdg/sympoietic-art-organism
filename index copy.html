<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sympoietic Art Organism</title>

  <!-- Modern Font -->
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;600&display=swap" rel="stylesheet" />

  <style>
    body {
      margin: 0;
      font-family: 'DM Sans', system-ui, sans-serif;
      background: #101011;
      color: #a3d9ca;
      overflow: hidden;
    }

    #menu {
      position: fixed;
      top: 16px;
      left: 16px;
      background: rgba(20, 30, 40, 0.9);
      border-radius: 12px;
      padding: 16px 24px;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
      box-shadow: inset 0 0 12px rgba(0, 238, 170, 0.1);
      transition: width 0.3s ease, padding 0.3s ease;
    }

    #menu.closed {
      width: auto;
      padding: 16px 12px;
      flex-direction: row;
      align-items: center;
    }

    #title-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex-grow: 1;
    }

    #menu.closed #title-container,
    #menu.closed #subtitle,
    #menu.closed #nav-box {
      display: none;
    }

    #title {
      font-size: 1.5rem;
      font-weight: 600;
      margin: 0;
      color: #a3d9ca;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    #title:hover {
      color: #00eeaa;
    }

    #subtitle {
      font-size: 1rem;
      opacity: 0.8;
      color: #a3d9ca;
    }

    #nav-box {
      background: rgba(0, 238, 170, 0.1);
      border: 1px solid rgba(0, 238, 170, 0.2);
      border-radius: 8px;
      padding: 12px;
    }

    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    nav ul li a {
      color: #a3d9ca;
      text-decoration: none;
      font-weight: 600;
      font-size: 1.1rem;
      padding: 6px 12px;
      border-radius: 10px;
      transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    nav ul li a:hover {
      background-color: #00eeaa;
      color: #042822;
      box-shadow: 0 0 8px 2px #00eeaa88;
    }

    #title-vertical {
      display: none;
    }

    #menu.closed #title-vertical {
      display: block;
      font-size: 1.4rem;
      font-weight: 600;
      color: #a3d9ca;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      max-height: 160px;
    }

    #buttons-container {
      display: flex;
      gap: 12px;
    }

    #menu.closed #buttons-container {
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    button {
      background: #184e68;
      border: none;
      border-radius: 12px;
      color: #a3d9ca;
      cursor: pointer;
      padding: 10px 18px;
      font-size: 1rem;
      transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover {
      background: #00eeaa;
      color: #042822;
      box-shadow: 0 0 8px 2px #00eeaa88;
    }

    #toggle-btn {
      width: 40px;
      height: 40px;
      font-size: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease;
    }

    #menu.closed #copy-btn {
      padding: 0;
      width: 40px;
      height: 170px;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 1rem;
    }

    #copy-confirmation {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translate(-50%, 20px);
      background: #00eeaacc;
      color: #042822;
      padding: 10px 24px;
      border-radius: 14px;
      font-weight: 600;
      font-size: 1rem;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 1000;
    }

    #copy-confirmation.visible {
      opacity: 1;
      transform: translate(-50%, 0);
      pointer-events: auto;
    }

    #3d-graph {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 0;
      background: #000003;
    }

    /* Radial fade overlay */
    #graph-overlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, #0f1520 100%);
      z-index: 1;
      pointer-events: none;
    }

    /* Responsive tweaks */
    @media (max-width: 768px) {
      #menu {
        width: 90vw;
        padding: 12px 16px;
      }

      #menu.closed {
        padding: 12px 10px;
      }

      #title {
        font-size: 1.2rem;
      }

      #subtitle {
        font-size: 0.9rem;
      }

      nav ul li a {
        font-size: 1rem;
      }

      button {
        font-size: 0.9rem;
        padding: 8px 14px;
      }

      #menu.closed #copy-btn {
        height: 120px;
        font-size: 0.8rem;
      }

      #title-vertical {
        max-height: 120px;
      }
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/3d-force-graph"></script>
</head>

<body>
  <nav id="menu">
    <div id="title-container">
      <a href="https://phileasdg.github.io/sympoietic/" id="title">Sympoietic Art Organism</a>
      <p id="subtitle">This project aims to grow a sympoietic art organism. To cultivate an art ecosystem by drawing from and enriching shared artistic commons. To showcase art that mixes media and visions, that brings out the analog from digital, and digitizes the analog.</p>
    </div>
    <div id="title-vertical">Sympoietic Art Organism</div>
    <div id="nav-box">
      <ul>
        <li><a href="https://phileasdg.github.io/sympoietic/manifesto.html">Manifesto</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/digital-gallery.html">Galleries</a></li>
        <li><a href="https://phileasdg.github.io/sympoietic/artists.html">About</a></li>
      </ul>
    </div>
    <div id="buttons-container">
      <button id="toggle-btn">Ã—</button>
      <button id="copy-btn">ðŸ“‹ Copy network edge list</button>
    </div>
  </nav>

  <div id="copy-confirmation">Copied!</div>
  <div id="3d-graph"></div>
  <div id="graph-overlay"></div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three';

    // Generate 250 nodes with different types
    const nodeTypes = [
      'concept', 'artwork', 'artist', 'medium', 'technique', 
      'movement', 'theme', 'emotion', 'color', 'texture',
      'sound', 'vision', 'memory', 'dream', 'reality'
    ];

    const nodeColors = {
      concept: '#FF6B6B',
      artwork: '#4ECDC4', 
      artist: '#45B7D1',
      medium: '#96CEB4',
      technique: '#FFEAA7',
      movement: '#DDA0DD',
      theme: '#98D8C8',
      emotion: '#F7DC6F',
      color: '#BB8FCE',
      texture: '#85C1E9',
      sound: '#F8C471',
      vision: '#82E0AA',
      memory: '#F1948A',
      dream: '#C39BD3',
      reality: '#7FB3D3'
    };

    // Generate nodes
    const nodes = Array.from({length: 250}, (_, i) => {
      const type = nodeTypes[i % nodeTypes.length];
      return {
        id: i,
        name: `${type}_${Math.floor(i / nodeTypes.length) + 1}`,
        type: type,
        size: Math.random() * 3 + 1,
        intensity: Math.random()
      };
    });

    // Define the network using an edge list
    // Each edge is [source_node, target_node]
    // You can easily replace this with your own edge data
    function createEdgeList() {
      const edges = [];
      
      // Example edge patterns - replace with your actual data
      // Sequential connections
      for (let i = 0; i < 249; i++) {
        edges.push([i, i + 1]);
      }
      
      // Some reverse connections
      for (let i = 10; i < 240; i += 10) {
        edges.push([i, i - 5]);
      }
      
      // Hub connections (some nodes are more connected)
      const hubs = [25, 75, 125, 175, 225];
      hubs.forEach(hub => {
        for (let i = 0; i < 10; i++) {
          const target = hub + i * 5;
          if (target < 250 && target !== hub) {
            edges.push([hub, target]);
          }
        }
      });
      
      // Random long-distance connections
      for (let i = 0; i < 100; i++) {
        const source = Math.floor(Math.random() * 250);
        const target = Math.floor(Math.random() * 250);
        if (source !== target) {
          edges.push([source, target]);
        }
      }
      
      // Cluster connections
      for (let cluster = 0; cluster < 10; cluster++) {
        const start = cluster * 25;
        const end = Math.min(start + 25, 250);
        for (let i = start; i < end - 1; i++) {
          for (let j = i + 1; j < Math.min(i + 4, end); j++) {
            if (Math.random() < 0.6) {
              edges.push([i, j]);
            }
          }
        }
      }
      
      return edges;
    }

    const edgeList = createEdgeList();

    // Convert edge list to links for the graph
    const links = edgeList.map(edge => ({
      source: edge[0],
      target: edge[1]
    }));

    // Add curvature for bidirectional links
    const linkMap = new Map();
    links.forEach(link => {
      const key = `${link.source},${link.target}`;
      linkMap.set(key, link);
    });

    links.forEach(link => {
      const revKey = `${link.target},${link.source}`;
      if (link.source === link.target) {
        link.curvature = 0.5;
        link.rotation = 0;
      } else if (linkMap.has(revKey)) {
        if (link.source < link.target) {
          link.curvature = 0.3;
          link.rotation = 0;
        } else {
          link.curvature = -0.3;
          link.rotation = Math.PI / 4;
        }
      } else {
        link.curvature = 0;
        link.rotation = 0;
      }
    });

    // Build neighbor relationships
    nodes.forEach(node => {
      node.neighbors = [];
      node.links = [];
    });

    links.forEach(link => {
      const source = nodes[link.source];
      const target = nodes[link.target];
      source.neighbors.push(target);
      target.neighbors.push(source);
      source.links.push(link);
      target.links.push(link);
    });

    const gData = { nodes, links };

    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const baseArrowLength = 4;
    const hoverArrowLength = 8;

    const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
      .graphData(gData)
      .nodeThreeObject(node => {
        // Create different geometries based on node type
        let geometry;
        const type = node.type;
        
        if (type === 'concept' || type === 'theme') {
          geometry = new THREE.OctahedronGeometry(node.size);
        } else if (type === 'artwork' || type === 'vision') {
          geometry = new THREE.TetrahedronGeometry(node.size);
        } else if (type === 'artist' || type === 'emotion') {
          geometry = new THREE.SphereGeometry(node.size, 8, 6);
        } else if (type === 'medium' || type === 'technique') {
          geometry = new THREE.BoxGeometry(node.size, node.size, node.size);
        } else if (type === 'sound' || type === 'memory') {
          geometry = new THREE.ConeGeometry(node.size, node.size * 1.5, 6);
        } else {
          geometry = new THREE.IcosahedronGeometry(node.size);
        }
        
        const material = new THREE.MeshLambertMaterial({
          color: nodeColors[type] || '#6B8E23',
          transparent: true,
          opacity: 0.8
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        
        // Add subtle animation
        const animSpeed = 0.001 + Math.random() * 0.002;
        mesh.userData = { animSpeed };
        
        return mesh;
      })
      .nodeColor(node => {
        const baseColor = nodeColors[node.type] || '#6B8E23';
        if (highlightNodes.has(node)) {
          return node === hoverNode ? '#FFD700' : '#FF8C00';
        }
        return baseColor;
      })
      .linkWidth(link => highlightLinks.has(link) ? 3 : 0.5)
      .linkDirectionalParticles(link => highlightLinks.has(link) ? 3 : 0)
      .linkDirectionalParticleWidth(2)
      .linkDirectionalArrowLength(link => highlightLinks.has(link) ? hoverArrowLength : baseArrowLength)
      .linkDirectionalArrowRelPos(0.9)
      .linkDirectionalArrowColor(link => highlightLinks.has(link) ? '#FF4500' : '#00EEAA')
      .linkColor(link => highlightLinks.has(link) ? '#FF8C00' : '#00EEAA')
      .linkCurvature(link => link.curvature || 0)
      .linkCurveRotation(link => link.rotation || 0)
      .linkOpacity(0.6)
      .nodeLabel(node => `${node.name} (${node.type})`)
      .onNodeHover(node => {
        if ((!node && !highlightNodes.size) || (node && hoverNode === node)) return;

        highlightNodes.clear();
        highlightLinks.clear();

        if (node) {
          highlightNodes.add(node);
          node.neighbors.forEach(n => highlightNodes.add(n));
          node.links.forEach(l => highlightLinks.add(l));
        }

        hoverNode = node || null;
        updateHighlight();
      })
      .onLinkHover(link => {
        highlightNodes.clear();
        highlightLinks.clear();

        if (link) {
          highlightLinks.add(link);
          highlightNodes.add(link.source);
          highlightNodes.add(link.target);
        }

        updateHighlight();
      })
      .onNodeClick(node => {
        if (!node) return;
        const distance = 50;
        const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
        const newPos = {
          x: node.x * distRatio,
          y: node.y * distRatio,
          z: node.z * distRatio
        };
        Graph.cameraPosition(newPos, node, 2000);
      });

    // Add ambient lighting
    const scene = Graph.scene();
    const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 10, 5);
    scene.add(directionalLight);

    // Animate node rotations
    function animateNodes() {
      nodes.forEach(node => {
        const obj = Graph.getObjectByProperty('userData.nodeId', node.id);
        if (obj && obj.userData.animSpeed) {
          obj.rotation.x += obj.userData.animSpeed;
          obj.rotation.y += obj.userData.animSpeed * 0.7;
        }
      });
      requestAnimationFrame(animateNodes);
    }
    animateNodes();

    function updateHighlight() {
      Graph
        .nodeColor(Graph.nodeColor())
        .linkWidth(Graph.linkWidth())
        .linkDirectionalParticles(Graph.linkDirectionalParticles())
        .linkDirectionalArrowColor(Graph.linkDirectionalArrowColor())
        .linkDirectionalArrowLength(Graph.linkDirectionalArrowLength())
        .linkColor(Graph.linkColor());
    }

    // Menu toggle with rotation
    const toggleBtn = document.getElementById('toggle-btn');
    toggleBtn.addEventListener('click', () => {
      const menu = document.getElementById('menu');
      const closed = menu.classList.toggle('closed');
      toggleBtn.textContent = closed ? 'â˜°' : 'Ã—';
      toggleBtn.style.transform = closed ? 'rotate(0deg)' : 'rotate(90deg)';
    });

    // Copy edge list function
    document.getElementById('copy-btn').addEventListener('click', async () => {
      try {
        const text = '// Edge list for ' + nodes.length + '-node network:\n// Format: [source_node, target_node]\n[\n' + 
          edgeList.map(edge => '  [' + edge[0] + ', ' + edge[1] + ']').join(',\n') + '\n]\n\n' +
          '// Total edges: ' + edgeList.length;
        
        await navigator.clipboard.writeText(text);
        const confirm = document.getElementById('copy-confirmation');
        confirm.classList.add('visible');
        setTimeout(() => confirm.classList.remove('visible'), 1500);
      } catch (err) {
        alert('Copy failed');
      }
    });
  </script>
</body>
</html>